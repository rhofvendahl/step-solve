import copy

# assumes already stripped, not empty, and consists of alphanum and/or "."
def tokenize_literal(literal):
    # Possible float
    if '.' in literal:
        # if literal == '.':
        #     raise Exception('User Error: Solitary "." is not a valid literal.')
        # if not ''.join(literal.split('.')).isnumeric():
        #     raise Exception('User Error: Cannot start string literal with a digit.')

        # Literal has more than one "." or invalid characters.
        if literal.count('.') > 1 or not ''.join(literal.split('.')).isnumeric():
            raise Exception('User Error: "' + literal + '" is not a number.')
        else:
            return {'type': 'float', 'value': float(literal)}
    # Possible integer
    elif literal.isnumeric():
        return {'type': 'integer', 'value': int(literal)}
    else:
        raise Exception('User Error: Literal not recognized.')

token_types = [
    'operator',
    'integer',
    'float',
]

operators = [
    '(',
    ')',
    '^',
    # Internal, generated by "establish_negatives", multiplies a following number by "-1" in "resolve_negatives".
    'neg',
    '*',
    '/',
    '+',
    '-',
]

def tokenize(text):
    tokens = []
    i = 0
    while i < len(text):
        if text[i].isnumeric() or text[i] == '.':
            j = i
            while j < len(text) and (text[j].isnumeric() or text[j] == '.'):
                j += 1
            literal = text[i:j]
            tokens.append(tokenize_literal(literal))
            i = j-1
        elif text[i] in '()^*/+-':
            tokens.append({'type': 'operator', 'value': text[i]})
        elif text[i].isspace():
            pass
        else:
            raise Exception('User Error: "' + text[i] + '" is not a valid character.')
        i += 1
    return tokens

# NOT intended to handle errors.
def establish_negatives(tokens):
    new_tokens = []
    for i in range(len(tokens)):
        # Is candidate for conversion to "neg".
        if tokens[i]['value'] == '-':
            is_negative = True
            # Minus is at the end.
            if i+1 == len(tokens):
                is_negative = False
            # Minus is follwed by an operator other than "(".
            elif tokens[i+1]['type'] == 'operator' and tokens[i+1]['value'] != '(':
                is_negative = False
            # Minus follows a number.
            elif i > 0 and tokens[i-1]['type'] in ['integer', 'float']:
                is_negative = False
            # Minus is followed by a number followed by an exponent sign, which operates before negative conversion.
            elif i+2 < len(tokens) and tokens[i+2]['value'] == '^':
                is_negative = False

            if is_negative:
                new_tokens.append({'type': 'operator', 'value': 'neg'})
            else:
                new_tokens.append({'type': 'operator', 'value': '-'})

        # Not a candidate for conversion for "neg".
        else:
            new_tokens.append({'type': tokens[i]['type'], 'value': tokens[i]['value']})
    return new_tokens

# HOH DAMN did I have "if I >= len(tokens)" instead of "if i+1 >= len(tokens)"? that's pretty big...

# Handles errors related to bad "neg"s.
def resolve_negatives(tokens):
    new_tokens = []
    i = 0
    while i < len(tokens):
        # Is already established as a neg sign.
        if tokens[i]['value'] == 'neg':
            # Is at the end of expression (internal because it shouldn't have been converted if at end).
            if i+1 >= len(tokens):
                raise Exception('Internal Error: Expression cannot end with a "neg".')
            # Is followed by "(".
            elif tokens[i+1]['value'] == '(':
                new_tokens.append({'type': 'operator', 'value': 'neg'})
            # Is followed by a number.
            elif tokens[i+1]['type'] in ['integer', 'float']:
                negative_token = {'type': tokens[i+1]['type'], 'value': -1 * tokens[i+1]['value']}
                new_tokens.append(negative_token)
                i += 1
            # Is followed by something other than "(" or a number  (internal be cause shouldn't have been converted if so).
            else:
                raise Exception('Internal Error: "Neg"s must be followed by "(" or a number.')
        # Is not a negative sign.
        else:
            new_tokens.append({'type': tokens[i]['type'], 'value': tokens[i]['value']})
        i += 1
    return new_tokens

# Assumes no "negs" or parentheses.
def perform_simple_operation(tokens):
    if len(tokens) == 1:
        return copy.deepcopy(tokens)

    token_values = [token['value'] for token in tokens]
    for operator in '^*/+-':
        if operator in token_values:
            i = token_values.index(operator) # Hm, only works bc both loops go l->r...?
            if i == 0:
                raise Exception('User Error: Expression cannot start with operator.')
            if i == len(tokens)-1:
                raise Exception('User Error: Expression cannot end with an operator.')
            if tokens[i-1]['type'] not in ['integer', 'float'] or tokens[i+1]['type'] not in ['integer', 'float']:
                raise Exception('User Error: "' + tokens[i]['value'] + '" operator requires numeric operands.')
        
            left_operand = tokens[i-1]
            operator = tokens[i]
            right_operand = tokens[i+1]
            if left_operand['type'] == 'float' or right_operand['type'] == 'float':
                new_type = 'float'
            else:
                new_type  = 'integer'
            if operator['value'] == '^':
                new_value = left_operand['value']**right_operand['value']
            elif operator['value'] == '*':
                new_value = left_operand['value']*right_operand['value']
            elif operator['value'] == '/':
                new_value = left_operand['value']/right_operand['value']
            elif operator['value'] == '+':
                new_value = left_operand['value']+right_operand['value']
            elif operator['value'] == '-':
                new_value = left_operand['value']-right_operand['value']

            new_token = {'type': new_type, 'value': new_value}
            return copy.deepcopy(tokens[:i-1]) + [new_token] + copy.deepcopy(tokens[i+2:])
    else:
        raise Exception('User Error: Multiple tokens in expression with no operator.')

# Capable of handling negs, parentheses.
def perform_operation(tokens):
    # Search for first set of innermost parentheses.
    paren_start = None
    paren_end = None
    for i in range(len(tokens)):
        if tokens[i]['value'] == '(':
            paren_start = i
        elif tokens[i]['value'] == ')':
            paren_end = i
            break

    # Handle mismatched parentheses.
    if paren_start != None and  paren_end == None:
        raise Exception('User Error: Missing ")"')
    if paren_end != None and paren_start == None:
        raise Exception('User Error: Missing "("')

    # We'll be working within parentheses this round.
    if paren_start != None:
        contents = tokens[paren_start+1:paren_end]
        if not contents:
            raise Exception('User Error: Parentheses cannot be empty.')
        contents_operated = perform_simple_operation(contents)

        if len(contents_operated) == 1 and contents_operated[0]['type'] in ['integer', 'float']:
            new_tokens = copy.deepcopy(tokens[:paren_start]) + contents_operated + copy.deepcopy(tokens[paren_end+1:])
        else:
            new_tokens = copy.deepcopy(tokens[:paren_start+1]) + contents_operated + copy.deepcopy(tokens[paren_end:])
    # There are no parentheses remaining.
    else:
        new_tokens = perform_simple_operation(tokens)

    new_tokens = resolve_negatives(new_tokens)
    return new_tokens

def evaluate(text):
    tokens = tokenize(text)

    # if not [token for token in tokens if token['type'] in ['integer', 'float']]:
    #     raise Exception('User Error: Expression must contain one or more numbers.')

    tokens = establish_negatives(tokens)
    tokens = resolve_negatives(tokens)
    steps = [tokens]
    while len(steps[-1]) > 1:
        tokens = steps[-1]
        tokens = perform_operation(tokens)
        steps.append(tokens)
        
    return steps

def format_tokens(tokens):
    formatted = ' '.join([str(token['value']) for token in tokens])
    formatted = '-('.join(formatted.split('neg ('))
    return formatted

steps = evaluate('++++')
for tokens in steps:
    print(format_tokens(tokens))

# ISSUES:
    # None I'm aware of :-).

# TODO:
    # More consistent errors (not scattered around with different text).