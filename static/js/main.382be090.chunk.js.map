{"version":3,"sources":["components/Input.tsx","constants.ts","solve.ts","components/Step.tsx","components/Description.tsx","components/ErrorMessage.tsx","components/Solver.tsx","components/App.tsx","index.tsx"],"names":["Input","value","onChange","className","type","event","colors","tokenizeLiteral","literal","isNaN","Number","Error","split","length","parseFloat","parseInt","resolveNegatives","tokens","newTokens","i","nextToken","push","newValue","performMathOperation","tokenValues","map","token","operators","operatorIndex","includes","indexOf","undefined","newToken","leftOperand","rightOperand","operator","toString","Math","pow","leftTokens","slice","rightTokens","concat","performOperation","parenStart","parenEnd","contents","contentsOperated","formatFloat","number","digits","formatted","toFixed","describeOperation","prevTokens","j","operationOutput","start","end","k","operationInput","inputTokens","description","n","nString","lastDigit","charAt","truncated","suffix","formatOrdinal","operationDescription","evaluate","text","tokenize","isNegative","establishNegatives","prevStep","computeNext","computed","steps","error","Step","initial","step","index","computeNextInterval","indexedTokens","computedColor","computeNextColor","mapTokens","adjustedValue","style","color","fontWeight","preComputeNext","postComputeNext","computeNextInner","border","Description","descriptionColor","ErrorMessage","message","newMessage","join","toLowerCase","softenMessage","Solver","React","useState","expression","setExpression","setSteps","setError","updateState","evaluateResult","useEffect","target","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.382be090.chunk.js","sourcesContent":["import React from 'react';\nimport '../styles/Input.css';\n\ntype InputProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n}\n\nconst Input = ({ value, onChange }: InputProps) => {\n  return (\n    <div className='input'>\n      <input\n        type='text'\n        value={value}\n        onChange={(event: React.ChangeEvent<HTMLInputElement>): void => onChange(event)}\n      />\n    </div>\n  );\n};\n\nexport default Input;\n","const colors = [\n  '#CC0B00',\n  '#E69138',\n  '#F1C231',\n  '#6AA850',\n  '#3D85C6',\n  '#674FA7'\n];\n\nexport { colors };","// Debugging utility.\nconst formatTokens = (tokens: Token[]): string => {\n  let formatted = tokens.map((token) => token.value.toString()).join(' ')\n  formatted = formatted.split('neg (').join('-(')\n  return formatted\n}\n\nexport type TokenType = 'operator' | 'number';\nexport type TokenValue = string | number;\nexport type Token = {\n  type: TokenType,\n  value: TokenValue\n};\n\nexport type Interval = {\n  start: number,\n  end: number\n}\n\nexport type Step = {\n  tokens: Token[],\n  description: string,\n  computed: Interval | null,\n  computeNext: Interval | null\n}\n\nconst tokenizeLiteral = (literal: string): Token => {\n  if (!isNaN(Number(literal)) && literal !== '') {\n    if (literal.split('.').length === 2) {\n      return {type: 'number', value: parseFloat(literal)};\n    } else {\n      return {type: 'number', value: parseInt(literal)};\n    }\n  } else {\n    throw new Error('User Error: Literal not recognized.');\n  }\n};\n\nconst tokenize = (text: string): Token[] => {\n  let tokens: Token[] = [];\n  for (let i=0; i < text.length; i++) {\n    // Char at i is a number or \".\".\n    if (!isNaN(parseInt(text.charAt(i))) || text.charAt(i) === '.') {\n      let j = i;\n      while (j < text.length && (!isNaN(parseInt(text.charAt(j))) || text.charAt(j) === '.')) {\n        j += 1;\n      }\n      const literal = text.slice(i, j);\n      const token = tokenizeLiteral(literal);\n      tokens.push(token);\n      i = j-1;\n    // Char at i is an operator.\n    } else if ('()^*/+-'.includes(text.charAt(i))) {\n      const token: Token = {type: 'operator', value: text.charAt(i)}\n      tokens.push(token);\n    } else if (text.charAt(i) !== ' ') {\n      throw new Error('User Error: \"' + text[i] + '\" is not a valid character.');\n    }\n  }\n  return tokens;\n};\n\n// NOT intended to handle errors.\nconst establishNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i < tokens.length; i++) {\n    // Is a candidate for conversion to \"neg\".\n    if (tokens[i].value === '-') {\n      let isNegative = true;\n      // Minus is at the end.\n      if (i+1 === tokens.length) {\n        isNegative = false;\n      // Minus is followed by an operator other than \"(\".\n      } else if (tokens[i+1].type === 'operator' && tokens[i+1].value !== '(') {\n        isNegative = false;\n      // Minus follows a number.\n      } else if (i > 0 && tokens[i-1].type === 'number') {\n        isNegative = false;\n      // Minus is followed by a number followed by an exponent sign (which operates before negative conversion).\n      } else if (i+2 < tokens.length && tokens[i+2].value === '^') {\n        isNegative = false\n      }\n\n      if (isNegative) {\n        newTokens.push({type: 'operator', value: 'neg'})\n      } else {\n        newTokens.push({type: 'operator', value: '-'})\n      }\n    // Not a candidate for conversion to \"neg\".\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value})\n    }\n  }\n  return newTokens;\n};\n\n// Only handles errors related to bad \"neg\"s.\nconst resolveNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === 'neg') {\n      // Is at the end of expression (internal because it shouldn't have been converted if at end).\n      if (i+1 >= tokens.length) {\n        throw new Error('Internal Error: Expression cannot end with a \"neg\" operator.');\n      } else {\n        const nextToken = tokens[i+1];\n        // Is followed by \"(\".\n        if (nextToken.value === '(') {\n          newTokens.push({type: 'operator', value: 'neg'});\n        // Is followed by a number.\n        } else if (typeof nextToken.value == 'number') {\n          let newValue = -1 * nextToken.value;\n          // DO NOT resolve \"neg 0\" to \"-0\".\n          if (nextToken.value === 0) {\n            newValue = 0;\n          }\n          newTokens.push({type: 'number', value: newValue});\n          i += 1;\n        // Is followed by something other than \"(\" or a number (internal because shouldn't have been converted if so).\n        } else {\n          throw new Error('Internal Error: \"neg\"s must be followed by \"(\" or a number.');\n        }\n      }\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value});\n    }\n  }\n  return newTokens;\n};\n\n// Assumes no \"neg\"s or parentheses; handles most other input logic errors.\nconst performMathOperation = (tokens: Token[]): Token[] => {\n  if (tokens.length === 1) {\n    if (tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist only of an operator.');\n    } else {\n      return [{type: 'number', value: tokens[0].value}]; \n    }\n  }\n\n  const tokenValues: TokenValue[] = tokens.map((token) => token.value);\n  const operators = ['^', '*', '/', '+', '-'];\n  let operatorIndex: number | undefined = -1;\n  for (let i=0; i<operators.length; i++) {\n    if (tokenValues.includes(operators[i])) {\n      operatorIndex = tokenValues.indexOf(operators[i]);\n      break;\n    };\n  };\n\n  if (operatorIndex === undefined) {\n    throw new Error('User Error: Multiple tokens in expression with no operator.');\n  } else if (operatorIndex === 0) {\n    throw new Error('User Error: Expression cannot start with an operator.');\n } else if (operatorIndex === tokens.length-1) {\n   throw new Error('User Error: Expression cannot end with an operator.');\n  }\n\n  let newToken: Token | undefined = undefined;\n\n  const leftOperand: Token = tokens[operatorIndex-1];\n  const rightOperand: Token = tokens[operatorIndex+1];\n  const operator: Token = tokens[operatorIndex];\n  if (typeof leftOperand.value === 'number' && typeof rightOperand.value === 'number') {\n    let newValue: number | undefined = undefined;\n    if (operator.value === '^') {\n      if (leftOperand.value < 0 && rightOperand.value % 1 !== 0) {\n        throw new Error('User Error: ' + leftOperand.value.toString() + '^' + rightOperand.value.toString() + ' results in an imaginary number, which is not supported.')\n      }\n      newValue = Math.pow(leftOperand.value, rightOperand.value);\n    } else if (operator.value === '*') {\n      newValue = leftOperand.value*rightOperand.value;\n    } else if (operator.value === '/') {\n      newValue = leftOperand.value/rightOperand.value;\n    } else if (operator.value === '+') {\n      newValue = leftOperand.value+rightOperand.value;\n    } else if (operator.value === '-') {\n      newValue = leftOperand.value-rightOperand.value;\n    }\n    if (newValue === undefined) {\n      throw new Error('Internal Error: \"' + operator.value + '\" operator not recognized.');\n    } else {\n      newToken = {type: 'number', value: newValue};\n    }\n  } else {\n    throw new Error('User Error: \"' + operator.value + '\" operator requires numeric operands.');\n  }\n  \n  if (newToken === undefined) {\n    throw new Error('Internal error: performSimpleOperation function failed.');\n  } else {\n    const leftTokens = tokens.slice(0, operatorIndex-1).map((token) => ({type: token.type, value: token.value}));\n    const rightTokens = tokens.slice(operatorIndex+2).map((token) => ({type: token.type, value: token.value}));\n    const newTokens = leftTokens.concat([newToken]).concat(rightTokens);      \n    return newTokens;\n  }\n};\n\n// Only handles errors to do with parentheses.\n// I'm thinking THIS should return a step...\nconst performOperation = (tokens: Token[]): Token[] => {\n  let parenStart: number | undefined = undefined;\n  let parenEnd: number | undefined = undefined;\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === '(') {\n      parenStart = i;\n    } else if (tokens[i].value === ')') {\n      parenEnd = i;\n      break;\n    }\n  }\n\n  if ((parenStart === undefined) !== (parenEnd === undefined)) {\n    throw new Error('User Error: Mismatched parentheses.');\n  }\n\n  let newTokens: Token[] | undefined = undefined;\n\n  // We'll be working within parentheses.\n  if (parenStart !== undefined && parenEnd !== undefined) {\n    const contents: Token[] = tokens.slice(parenStart+1, parenEnd);\n    if (contents.length === 0) {\n      throw new Error('User Error: Parentheses cannot be empty.');\n    }\n    const contentsOperated = performMathOperation(contents);\n    // Contents operated contains single number.\n    if (contentsOperated.length === 1 && contentsOperated[0].type === 'number') {\n      // Remove parentheses when concatenating.\n      const leftTokens = tokens.slice(0, parenStart).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd+1).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    // Contents operated contains multiple numbers (error cases handled within perform math operation).\n    } else {\n      const leftTokens = tokens.slice(0, parenStart+1).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    }\n  // There are no parentheses remaining.\n  } else {\n    newTokens = performMathOperation(tokens);\n  }\n\n  if (newTokens !== undefined) {\n    newTokens = resolveNegatives(newTokens);\n    return newTokens;\n  } else {\n    throw new Error('Internal Error: \"performOperation\" function failed.');\n  }\n};\n\nconst formatOrdinal = (n: number): string => {\n  const nString = n.toString();\n  if (n % 1 !== 0) {\n    return nString + 'th';\n  }\n  const lastDigit = parseInt(nString.charAt(nString.length-1));\n  const truncated = n % 100;\n  let suffix = 'th';\n  if (lastDigit === 1 && truncated !== 11) {\n    suffix = 'st';\n  } else if (lastDigit === 2 && truncated !== 12) {\n    suffix = 'nd';\n  } else if (lastDigit === 3 && truncated !== 13) {\n    suffix = 'rd';\n  }\n  return nString + suffix;\n}\n\nconst formatFloat = (number: number, digits: number): string => {\n  let formatted: number | string = number;\n  // Using workaround to assess digits after decimal, as  \"3.1 % 1\" yields \"0.1000000000000000001\" (not what we want).\n  if (formatted % 1 !== 0 && formatted.toString().split('.')[1].length > digits) {\n    formatted = parseFloat(number.toFixed(digits)).toString() + '...';\n  } else {\n    formatted = number.toString();\n  }\n  return formatted;\n}\n\n// Awkward, but easier & simpler than tracking and passing changes through all of the index-changing operations (math operations, resolving parentheses, resolving negatives).\n// Assumes both sequences describe valid equations.\nconst describeOperation = (prevTokens: Token[], newTokens: Token[]): { operationInput: Interval, operationOutput: Interval, operationDescription: string } => {\n  let i = prevTokens.length-1;\n  let j = newTokens.length-1;\n  // Move along both sets of tokens, iterating backward to ensure that i hits the first operator in cases like \"1*1*1\" to \"1*1\".\n  while (i >= 0 && j >= 0 && prevTokens[i].value === newTokens[j].value) {\n    i -= 1;\n    j -= 1;\n  }\n\n  // Case where input and output share ending numbers (eg. \"1*1+1\" to \"1+1\"), so i continues on to the operator that was resolved.\n    // I believe all remaining cases leave i and j at the end of the input & output sequences.\n    // Including \"(1)\", where there is no operator; and \"1*1*1\" to \"1*1\", where j hits the end of the array.\n  if (prevTokens[i].type === 'operator' && prevTokens[i].value !== ')') {\n    i += 1;\n    j += 1;\n  }\n  const operationOutput: Interval = {\n    start: j,\n    end: j+1\n  };\n  let k = i;\n  // Cases with inputs like \"(1)\", \"(1+1)\", \"neg(1)\", \"neg(1+1)\".\n  if (prevTokens[i].value === ')') {\n    while (k >= 0 && prevTokens[k].value !== '(') {\n      k -= 1;\n    }\n    if (k > 0 && prevTokens[k-1].value === 'neg') {\n      k -= 1;\n    }\n  // Cases with inputs like \"1+1\".\n  } else {\n    k -= 2;\n  }\n  const operationInput: Interval = {\n    start: k,\n    end: i+1\n  }\n  const inputTokens = prevTokens.slice(k, i+1);\n\n  let operatorIndex = 0;\n  for ( ; operatorIndex < inputTokens.length; operatorIndex++) {\n    const token = inputTokens[operatorIndex];\n    if (token.type === 'operator' && typeof token.value === 'string' && !['neg', '(', ')'].includes(token.value)) {\n      break;\n    }\n  }\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n  }\n\n  let description: string | undefined = undefined;\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n    throw new Error('Internal Error: \"describeOperation\" function recieved a misplaced operator.');\n  // No operator in expression (eg. \"(1)\" to \"1\").\n  } else if (operatorIndex === inputTokens.length) {\n    description = 'resolve parentheses';\n  } else if (operatorIndex < inputTokens.length) {\n    const leftOperand = inputTokens[operatorIndex-1].value;\n    const rightOperand = inputTokens[operatorIndex+1].value;\n    if (typeof leftOperand !== 'number' || typeof rightOperand !== 'number') {\n      throw new Error('Internal Error: \"describeOperation\" function received invalid operands.');\n    }\n    if (inputTokens[operatorIndex].value === '^') {\n      description = 'raise ' + formatFloat(leftOperand, 3) + ' to the ' + formatOrdinal(rightOperand) + ' power';\n    } else if (inputTokens[operatorIndex].value === '*') {\n      description = 'multiply ' + formatFloat(leftOperand, 3) + ' by ' + formatFloat(rightOperand, 3);\n    } else if (inputTokens[operatorIndex].value === '/') {\n      description = 'divide ' + formatFloat(leftOperand, 3) + ' by ' + formatFloat(rightOperand, 3);\n    } else if (inputTokens[operatorIndex].value === '+') {\n      description = 'add ' + formatFloat(rightOperand, 3) + ' to ' + formatFloat(leftOperand, 3);\n    } else if (inputTokens[operatorIndex].value === '-') {\n      description = 'subtract ' + formatFloat(rightOperand, 3) + ' from ' + formatFloat(leftOperand, 3);\n    }  \n  } else {\n\n  }\n  if (description === undefined) {\n    throw new Error('Internal Error: function \"describeOperation\" failed.');\n  }\n  return {\n    operationInput: operationInput,\n    operationOutput: operationOutput,\n    operationDescription: description\n  };\n};\n\nconst evaluate = (text: string): Step[] | Error => {\n  try {\n    let tokens = tokenize(text);\n    tokens = establishNegatives(tokens);\n    tokens = resolveNegatives(tokens);\n    if (tokens.length === 0) {\n      return [];\n    } else if (tokens.length === 1 && tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist of a single operator.');\n    }\n    let prevStep: Step = {\n      tokens: tokens,\n      description: '[Initial description.]',\n      computeNext: null,\n      computed: null,\n    };\n    const steps: Step[] = [];\n    while (prevStep.tokens.length > 1) {\n      const tokens = performOperation(prevStep.tokens);\n      const { operationInput, operationOutput, operationDescription } = describeOperation(prevStep.tokens, tokens);\n      prevStep.computeNext = operationInput;\n      steps.push(prevStep);\n      prevStep = {\n        computeNext: null,\n        tokens: tokens,\n        description: operationDescription,\n        computed: operationOutput\n      }\n    }\n    steps.push(prevStep);\n    return steps;\n  } catch (error) {\n    return error;\n  }\n};\n\nexport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performMathOperation,\n  performOperation,\n  describeOperation,\n  evaluate,\n  formatTokens,\n  formatFloat\n};\n\n// NOTE\n  // Preference is to trust token.type, with typeof used when necessary for type narrowing.\n\n// TODO\n  // Returns and conditionals and exceptions all over the place are leaving things a mess (especially performMathOperation).\n    // In theory having early returns makes it so there are guarantees down the line, but that gets messy fast.....\n  // Ya, checks and exceptions are all over the place. resolve that.\n  // Consider un-refactoring the '\"number\"' back to '\"float\" | \"integer\"', since apparently JS/TS is terrible at discerning floats/ints from numbers\n  // Consider adding \"patentheses\" type, to simplify checking for \"operation but not parentheses\".","import React from 'react';\nimport { colors } from '../constants';\nimport { formatFloat } from '../solve';\nimport type { Token, Step as StepType } from '../solve';\nimport '../styles/Step.css';\n\ntype StepProps = {\n  initial?: boolean,\n  step: StepType,\n  index: number\n}\n\ntype IndexedToken = {\n  token: Token,\n  index: number\n}\n\nconst Step = ({ initial = false, step, index }: StepProps) => {\n  let computeNextInterval = step.computeNext || { start: 0, end: 0 };\n  const indexedTokens = step.tokens.map((token, i) => ({ token: token, index: i }));\n  const computedColor = step.computed ? colors[(index-1) % colors.length] : 'white';\n  const computeNextColor = step.computeNext ? colors[index % colors.length] : 'white';\n\n  const mapTokens = ({ token, index }: IndexedToken): React.ReactNode => {\n    let adjustedValue = token.value;\n    if (typeof adjustedValue === 'number') {\n      // Display more of decimal portion if it's the final result.\n      if (step.tokens.length === 1) {\n        adjustedValue = formatFloat(adjustedValue, 10);\n      } else {\n        adjustedValue = formatFloat(adjustedValue, 3);\n      }\n    }\n\n    if (index > 0 && step.tokens[index-1].value !== 'neg') {\n      adjustedValue = ' ' + adjustedValue;\n    }\n    if (adjustedValue === ' neg') {\n      adjustedValue = ' -';\n    }\n    if (step.computed !== null && index === step.computed.start) {\n      return (<span key={index} className='computed' style={{color: computedColor, fontWeight: 'bold'}}>{adjustedValue}</span>);\n    } else {\n      return (<span key={index}>{adjustedValue}</span>);\n    }\n  };\n  const preComputeNext = indexedTokens.slice(0, computeNextInterval.start).map(mapTokens);\n  const postComputeNext = indexedTokens.slice(computeNextInterval.end).map(mapTokens);\n  const computeNextInner = indexedTokens.slice(computeNextInterval.start, computeNextInterval.end).map(mapTokens);\n  let computeNext = (<></>)\n  if (computeNextInner.length > 0) {\n    computeNext = (<span className='compute-next' style={{border: '2px solid ' + computeNextColor}}>{computeNextInner}</span>)\n  }\n  return (\n    <div className={initial ? 'step step-initial' : 'step step-next'}>\n    <span className='expression'>\n      {preComputeNext}\n      {computeNext}\n      {postComputeNext}\n    </span>\n    </div>\n  );\n};\n\nexport default Step;\n","import React from 'react';\nimport { colors } from '../constants';\nimport '../styles/Description.css';\n\ntype DescriptionProps = {\n  description: string,\n  index: number\n}\n\nconst Description = ({ description, index }: DescriptionProps) => {\n  const descriptionColor = colors[(index) % colors.length];\n  return (\n    <div className='description' style={{color: descriptionColor}}>\n      {description}\n    </div>\n  );\n};\n\nexport default Description;\n","import React from 'react';\nimport '../styles/ErrorMessage.css';\n\ntype ErrorMessageProps = {\n  error: Error | null,\n}\n\nconst ErrorMessage = ({ error }: ErrorMessageProps) => {\n  const softenMessage = (message: string) => {\n    let newMessage = message;\n    if (newMessage.split('Internal Error').length > 1) {\n      return newMessage;\n    } else {\n      newMessage = newMessage.split('User Error: ').join('');\n      newMessage = newMessage.toLowerCase();\n      if (newMessage.charAt(newMessage.length-1) === '.') {\n        newMessage = newMessage.slice(0, newMessage.length-1);\n      }\n      return newMessage;\n    }\n  }\n  if (error === null) {\n    return null;\n  } else {\n    return (\n      <div className='error'>\n        {softenMessage(error.message)}\n      </div>\n    );\n  }\n};\n\nexport default ErrorMessage;\n","import React from 'react';\nimport Input from './Input';\nimport Step from './Step';\nimport Description from './Description';\nimport ErrorMessage from './ErrorMessage';\nimport { evaluate } from '../solve';\nimport type { Step as StepType } from '../solve';\nimport '../styles/Solver.css';\n\nconst Solver = () => {\n  const [expression, setExpression] = React.useState('');\n  const [steps, setSteps] = React.useState<StepType[] | null>(null)\n  const [error, setError] = React.useState<Error | null>(null);\n\n  const updateState = (text: string) => {\n    setExpression(text);\n    const evaluateResult = evaluate(text);\n    if (evaluateResult instanceof Error) {\n      setSteps(null);\n      setError(evaluateResult);\n    } else {\n      setSteps(evaluateResult);\n      setError(null);\n    };\n  }\n\n  // Call once at start to sync expression, steps, error.\n  React.useEffect(() => {\n    updateState('1-2+-(4/2-1.5)^-3*22');\n  }, [])\n\n  const onInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    const text = event.target.value;\n    updateState(text);\n  };\n\n  const getDescriptions = () => {\n    if (steps !== null && steps.length > 1) {\n      return steps.slice(1).map((step, i) => (\n        <Description\n          key={i}\n          description={step.description}\n          index={i}\n        />\n      ));\n    } else {\n      return null;\n    }\n  }\n\n  const getSteps = () => {\n    if (steps !== null && steps.length === 0) {\n      return null;\n    } else if (steps !== null && steps.length > 0) {\n      return (\n        <>\n          <Step\n            key={0}\n            initial={true}\n            step={steps[0]}\n            index={0}\n            />\n          {steps.slice(1).map((step, i) => (\n            <Step\n              key={i+1}\n              step={step}\n              index={i+1}\n            />\n          ))}\n       </>\n      );\n    } else {\n      return null;\n    }\n  }\n  return (\n    <div className='solver'>\n      <div className = 'solver-left'>\n        <Input\n          value={expression}\n          onChange={onInputChange}\n        />\n        {getDescriptions()}\n      </div>\n      <div className = 'solver-right'>\n        {getSteps()}\n      </div>\n      <ErrorMessage error={error} />\n    </div>\n  );\n};\n\nexport default Solver;\n","import React from 'react';\nimport Solver from './Solver';\nimport '../styles/App.css';\n\nconst App = () => {\n  return (\n    <div className='app'>\n      <Solver />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}