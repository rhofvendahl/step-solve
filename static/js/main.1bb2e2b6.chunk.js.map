{"version":3,"sources":["components/Input.tsx","constants.ts","solve.ts","components/Step.tsx","components/Description.tsx","components/ErrorMessage.tsx","components/Solver.tsx","components/App.tsx","index.tsx"],"names":["Input","value","onChange","className","type","event","colors","tokenizeLiteral","literal","isNaN","Number","Error","split","length","parseFloat","parseInt","resolveNegatives","tokens","newTokens","i","nextToken","push","newValue","performMathOperation","operatorGroups","operatorIndex","undefined","j","includes","newToken","leftOperand","rightOperand","operator","toString","Math","pow","leftTokens","slice","map","token","rightTokens","concat","performOperation","parenStart","parenEnd","contents","contentsOperated","formatFloat","number","digits","formatted","toFixed","describeOperation","prevTokens","operationOutput","start","end","k","operationInput","inputTokens","description","n","nString","lastDigit","charAt","truncated","suffix","formatOrdinal","operationDescription","evaluate","text","tokenize","isNegative","establishNegatives","prevStep","computeNext","computed","steps","error","Step","initial","step","index","computeNextInterval","indexedTokens","computedColor","computeNextColor","mapTokens","adjustedValue","style","color","fontWeight","preComputeNext","postComputeNext","computeNextInner","border","Description","descriptionColor","ErrorMessage","message","newMessage","join","toLowerCase","softenMessage","Solver","React","useState","expression","setExpression","setSteps","setError","updateState","evaluateResult","useEffect","target","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"4TAoBeA,EAZD,SAAC,GAAqC,IAAnCC,EAAkC,EAAlCA,MAAOC,EAA2B,EAA3BA,SACtB,OACE,qBAAKC,UAAU,QAAf,SACE,uBACEC,KAAK,OACLH,MAAOA,EACPC,SAAU,SAACG,GAAD,OAAsDH,EAASG,SCd3EC,EAAS,CACb,UACA,UACA,UACA,UACA,UACA,WCoBIC,EAAkB,SAACC,GACvB,GAAKC,MAAMC,OAAOF,KAAyB,KAAZA,EAO7B,MAAM,IAAIG,MAAM,uCANhB,OAAkC,IAA9BH,EAAQI,MAAM,KAAKC,OACd,CAACT,KAAM,SAAUH,MAAOa,WAAWN,IAEnC,CAACJ,KAAM,SAAUH,MAAOc,SAASP,KAmExCQ,EAAmB,SAACC,GAExB,IADA,IAAIC,EAAqB,GAChBC,EAAE,EAAGA,EAAEF,EAAOJ,OAAQM,IAC7B,GAAwB,QAApBF,EAAOE,GAAGlB,MAAiB,CAE7B,GAAIkB,EAAE,GAAKF,EAAOJ,OAChB,MAAM,IAAIF,MAAM,gEAEhB,IAAMS,EAAYH,EAAOE,EAAE,GAE3B,GAAwB,MAApBC,EAAUnB,MACZiB,EAAUG,KAAK,CAACjB,KAAM,WAAYH,MAAO,YAEpC,IAA8B,iBAAnBmB,EAAUnB,MAU1B,MAAM,IAAIU,MAAM,+DAThB,IAAIW,GAAY,EAAIF,EAAUnB,MAEN,IAApBmB,EAAUnB,QACZqB,EAAW,GAEbJ,EAAUG,KAAK,CAACjB,KAAM,SAAUH,MAAOqB,IACvCH,GAAK,QAOTD,EAAUG,KAAK,CAACjB,KAAMa,EAAOE,GAAGf,KAAMH,MAAOgB,EAAOE,GAAGlB,QAG3D,OAAOiB,GAIHK,EAAuB,SAACN,GAC5B,GAAsB,IAAlBA,EAAOJ,OAAc,CACvB,GAAuB,aAAnBI,EAAO,GAAGb,KACZ,MAAM,IAAIO,MAAM,8DAEhB,MAAO,CAAC,CAACP,KAAM,SAAUH,MAAOgB,EAAO,GAAGhB,QAM9C,IAFA,IAAMuB,EAAwC,CAAC,CAAC,KAAM,CAAC,IAAK,KAAM,CAAC,IAAK,MACpEC,OAAoCC,EAC/BP,EAAE,EAAGA,EAAEK,EAAeX,OAAQM,IAAK,CAE1C,IADA,IAAIQ,EAAI,EACAA,EAAIV,EAAOJ,OAAQc,GAAG,EAE5B,GAAIH,EAAeL,GAAGS,SAASX,EAAOU,GAAG1B,OAAQ,CAC/CwB,EAAgBE,EAChB,MAGJ,QAAsBD,IAAlBD,EACF,MAIJ,QAAsBC,IAAlBD,EACF,MAAM,IAAId,MAAM,+DACX,GAAsB,IAAlBc,EACT,MAAM,IAAId,MAAM,yDACZ,GAAIc,IAAkBR,EAAOJ,OAAO,EACzC,MAAM,IAAIF,MAAM,uDAGjB,IAAIkB,OAA8BH,EAE5BI,EAAqBb,EAAOQ,EAAc,GAC1CM,EAAsBd,EAAOQ,EAAc,GAC3CO,EAAkBf,EAAOQ,GAC/B,GAAiC,kBAAtBK,EAAY7B,OAAoD,kBAAvB8B,EAAa9B,MAsB/D,MAAM,IAAIU,MAAM,gBAAkBqB,EAAS/B,MAAQ,yCArBnD,IAAIqB,OAA+BI,EACnC,GAAuB,MAAnBM,EAAS/B,MAAe,CAC1B,GAAI6B,EAAY7B,MAAQ,GAAK8B,EAAa9B,MAAQ,IAAM,EACtD,MAAM,IAAIU,MAAM,eAAiBmB,EAAY7B,MAAMgC,WAAa,IAAMF,EAAa9B,MAAMgC,WAAa,4DAExGX,EAAWY,KAAKC,IAAIL,EAAY7B,MAAO8B,EAAa9B,WACxB,MAAnB+B,EAAS/B,MAClBqB,EAAWQ,EAAY7B,MAAM8B,EAAa9B,MACd,MAAnB+B,EAAS/B,MAClBqB,EAAWQ,EAAY7B,MAAM8B,EAAa9B,MACd,MAAnB+B,EAAS/B,MAClBqB,EAAWQ,EAAY7B,MAAM8B,EAAa9B,MACd,MAAnB+B,EAAS/B,QAClBqB,EAAWQ,EAAY7B,MAAM8B,EAAa9B,OAE5C,QAAiByB,IAAbJ,EACF,MAAM,IAAIX,MAAM,oBAAsBqB,EAAS/B,MAAQ,8BAQ3D,QAAiByB,KANbG,EAAW,CAACzB,KAAM,SAAUH,MAAOqB,IAOrC,MAAM,IAAIX,MAAM,2DAEhB,IAAMyB,EAAanB,EAAOoB,MAAM,EAAGZ,EAAc,GAAGa,KAAI,SAACC,GAAD,MAAY,CAACnC,KAAMmC,EAAMnC,KAAMH,MAAOsC,EAAMtC,UAC9FuC,EAAcvB,EAAOoB,MAAMZ,EAAc,GAAGa,KAAI,SAACC,GAAD,MAAY,CAACnC,KAAMmC,EAAMnC,KAAMH,MAAOsC,EAAMtC,UAElG,OADkBmC,EAAWK,OAAO,CAACZ,IAAWY,OAAOD,IAMrDE,EAAmB,SAACzB,GAGxB,IAFA,IAAI0B,OAAiCjB,EACjCkB,OAA+BlB,EAC1BP,EAAE,EAAGA,EAAEF,EAAOJ,OAAQM,IAC7B,GAAwB,MAApBF,EAAOE,GAAGlB,MACZ0C,EAAaxB,OACR,GAAwB,MAApBF,EAAOE,GAAGlB,MAAe,CAClC2C,EAAWzB,EACX,MAIJ,QAAoBO,IAAfiB,UAA4CjB,IAAbkB,GAClC,MAAM,IAAIjC,MAAM,uCAGlB,IAAIO,OAAiCQ,EAGrC,QAAmBA,IAAfiB,QAAyCjB,IAAbkB,EAAwB,CACtD,IAAMC,EAAoB5B,EAAOoB,MAAMM,EAAW,EAAGC,GACrD,GAAwB,IAApBC,EAAShC,OACX,MAAM,IAAIF,MAAM,4CAElB,IAAMmC,EAAmBvB,EAAqBsB,GAE9C,GAAgC,IAA5BC,EAAiBjC,QAA6C,WAA7BiC,EAAiB,GAAG1C,KAAmB,CAE1E,IAAMgC,EAAanB,EAAOoB,MAAM,EAAGM,GAAYL,KAAI,SAACC,GAAD,MAAY,CAACnC,KAAMmC,EAAMnC,KAAMH,MAAOsC,EAAMtC,UACzFuC,EAAcvB,EAAOoB,MAAMO,EAAS,GAAGN,KAAI,SAACC,GAAD,MAAY,CAACnC,KAAMmC,EAAMnC,KAAMH,MAAOsC,EAAMtC,UAC7FiB,EAAYkB,EAAWK,OAAOK,GAAkBL,OAAOD,OAElD,CACL,IAAMJ,EAAanB,EAAOoB,MAAM,EAAGM,EAAW,GAAGL,KAAI,SAACC,GAAD,MAAY,CAACnC,KAAMmC,EAAMnC,KAAMH,MAAOsC,EAAMtC,UAC3FuC,EAAcvB,EAAOoB,MAAMO,GAAUN,KAAI,SAACC,GAAD,MAAY,CAACnC,KAAMmC,EAAMnC,KAAMH,MAAOsC,EAAMtC,UAC3FiB,EAAYkB,EAAWK,OAAOK,GAAkBL,OAAOD,SAIzDtB,EAAYK,EAAqBN,GAGnC,QAAkBS,IAAdR,EAEF,OADAA,EAAYF,EAAiBE,GAG7B,MAAM,IAAIP,MAAM,wDAsBdoC,EAAc,SAACC,EAAgBC,GACnC,IAAIC,EAA6BF,EAOjC,OAJEE,EADEA,EAAY,IAAM,GAAKA,EAAUjB,WAAWrB,MAAM,KAAK,GAAGC,OAASoC,EACzDnC,WAAWkC,EAAOG,QAAQF,IAAShB,WAAa,MAEhDe,EAAOf,YAOjBmB,EAAoB,SAACC,EAAqBnC,GAI9C,IAHA,IAAIC,EAAIkC,EAAWxC,OAAO,EACtBc,EAAIT,EAAUL,OAAO,EAElBM,GAAK,GAAKQ,GAAK,GAAK0B,EAAWlC,GAAGlB,QAAUiB,EAAUS,GAAG1B,OAC9DkB,GAAK,EACLQ,GAAK,EAMoB,aAAvB0B,EAAWlC,GAAGf,OAChBe,GAAK,EACLQ,GAAK,GAEP,IAAM2B,EAA4B,CAChCC,MAAO5B,EACP6B,IAAK7B,EAAE,GAEL8B,EAAItC,EAER,GAA4B,MAAxBkC,EAAWlC,GAAGlB,MAAe,CAC/B,KAAOwD,GAAK,GAA6B,MAAxBJ,EAAWI,GAAGxD,OAC7BwD,GAAK,EAEHA,EAAI,GAA+B,QAA1BJ,EAAWI,EAAE,GAAGxD,QAC3BwD,GAAK,QAIPA,GAAK,EASP,IAPA,IAAMC,EAA2B,CAC/BH,MAAOE,EACPD,IAAKrC,EAAE,GAEHwC,EAAcN,EAAWhB,MAAMoB,EAAGtC,EAAE,GAEtCM,EAAgB,EACZA,EAAgBkC,EAAY9C,OAAQY,IAAiB,CAC3D,IAAMc,EAAQoB,EAAYlC,GAC1B,GAAmB,aAAfc,EAAMnC,MAAuC,QAAhBmC,EAAMtC,MACrC,MAGkB,IAAlBwB,GAAyCkC,EAAY9C,OAGzD,IAAI+C,OAAkClC,EACtC,GAAsB,IAAlBD,GAAuBA,IAAkBkC,EAAY9C,OAAO,EAC9D,MAAM,IAAIF,MAAM,+EAEX,GAAIc,IAAkBkC,EAAY9C,OACvC+C,EAAc,2BACT,GAAInC,EAAgBkC,EAAY9C,OAAQ,CAC7C,IAAMiB,EAAc6B,EAAYlC,EAAc,GAAGxB,MAC3C8B,EAAe4B,EAAYlC,EAAc,GAAGxB,MAClD,GAA2B,kBAAhB6B,GAAoD,kBAAjBC,EAC5C,MAAM,IAAIpB,MAAM,2EAEuB,MAArCgD,EAAYlC,GAAexB,MAC7B2D,EAAc,SAAWb,EAAYjB,EAAa,GAAK,WA7FvC,SAAC+B,GACrB,IAAMC,EAAUD,EAAE5B,WAClB,GAAI4B,EAAI,IAAM,EACZ,OAAOC,EAAU,KAEnB,IAAMC,EAAYhD,SAAS+C,EAAQE,OAAOF,EAAQjD,OAAO,IACnDoD,EAAYJ,EAAI,IAClBK,EAAS,KAQb,OAPkB,IAAdH,GAAiC,KAAdE,EACrBC,EAAS,KACc,IAAdH,GAAiC,KAAdE,EAC5BC,EAAS,KACc,IAAdH,GAAiC,KAAdE,IAC5BC,EAAS,MAEJJ,EAAUI,EA8EuDC,CAAcpC,GAAgB,SACpD,MAArC4B,EAAYlC,GAAexB,MACpC2D,EAAc,YAAcb,EAAYjB,EAAa,GAAK,OAASiB,EAAYhB,EAAc,GAC/C,MAArC4B,EAAYlC,GAAexB,MACpC2D,EAAc,UAAYb,EAAYjB,EAAa,GAAK,OAASiB,EAAYhB,EAAc,GAC7C,MAArC4B,EAAYlC,GAAexB,MACpC2D,EAAc,OAASb,EAAYhB,EAAc,GAAK,OAASgB,EAAYjB,EAAa,GAC1C,MAArC6B,EAAYlC,GAAexB,QACpC2D,EAAc,YAAcb,EAAYhB,EAAc,GAAK,SAAWgB,EAAYjB,EAAa,IAKnG,QAAoBJ,IAAhBkC,EACF,MAAM,IAAIjD,MAAM,wDAElB,MAAO,CACL+C,eAAgBA,EAChBJ,gBAAiBA,EACjBc,qBAAsBR,IAIpBS,EAAW,SAACC,GAChB,IACE,IAAIrD,EAhVS,SAACqD,GAEhB,IADA,IAAIrD,EAAkB,GACbE,EAAE,EAAGA,EAAImD,EAAKzD,OAAQM,IAE7B,GAAKV,MAAMM,SAASuD,EAAKN,OAAO7C,MAA2B,MAAnBmD,EAAKN,OAAO7C,IAU7C,GAAI,QAAQS,SAAS0C,EAAKN,OAAO7C,IACtCF,EAAOI,KAAK,CAACjB,KAAM,WAAYH,MAAOqE,EAAKN,OAAO7C,UAC7C,GAAI,KAAKS,SAAS0C,EAAKN,OAAO7C,IACnCF,EAAOI,KAAK,CAACjB,KAAM,cAAeH,MAAOqE,EAAKN,OAAO7C,UAChD,GAAuB,MAAnBmD,EAAKN,OAAO7C,GACrB,MAAM,IAAIR,MAAM,gBAAkB2D,EAAKnD,GAAK,mCAfkB,CAE9D,IADA,IAAIQ,EAAIR,EACDQ,EAAI2C,EAAKzD,UAAYJ,MAAMM,SAASuD,EAAKN,OAAOrC,MAA2B,MAAnB2C,EAAKN,OAAOrC,KACzEA,GAAK,EAEP,IAAMnB,EAAU8D,EAAKjC,MAAMlB,EAAGQ,GACxBY,EAAQhC,EAAgBC,GAC9BS,EAAOI,KAAKkB,GACZpB,EAAIQ,EAAE,EAUV,OAAOV,EA0TQsD,CAASD,GAGtB,GAFArD,EAvTuB,SAACA,GAE1B,IADA,IAAIC,EAAqB,GAChBC,EAAE,EAAGA,EAAIF,EAAOJ,OAAQM,IAE/B,GAAwB,MAApBF,EAAOE,GAAGlB,MAAe,CAC3B,IAAIuE,GAAa,GAEbrD,EAAE,IAAMF,EAAOJ,QAGa,aAArBI,EAAOE,EAAE,GAAGf,MAA6C,MAAtBa,EAAOE,EAAE,GAAGlB,OAG/CkB,EAAI,GAA0B,WAArBF,EAAOE,EAAE,GAAGf,MAGrBe,EAAE,EAAIF,EAAOJ,QAAgC,MAAtBI,EAAOE,EAAE,GAAGlB,SAR5CuE,GAAa,GAYXA,EACFtD,EAAUG,KAAK,CAACjB,KAAM,WAAYH,MAAO,QAEzCiB,EAAUG,KAAK,CAACjB,KAAM,WAAYH,MAAO,WAI3CiB,EAAUG,KAAK,CAACjB,KAAMa,EAAOE,GAAGf,KAAMH,MAAOgB,EAAOE,GAAGlB,QAG3D,OAAOiB,EAyRIuD,CAAmBxD,GAEN,KADtBA,EAASD,EAAiBC,IACfJ,OACT,MAAO,GACF,GAAsB,IAAlBI,EAAOJ,QAAmC,aAAnBI,EAAO,GAAGb,KAC1C,MAAM,IAAIO,MAAM,+DASlB,IAPA,IAAI+D,EAAiB,CACnBzD,OAAQA,EACR2C,YAAa,yBACbe,YAAa,KACbC,SAAU,MAENC,EAAgB,GACfH,EAASzD,OAAOJ,OAAS,GAAG,CACjC,IAAMI,EAASyB,EAAiBgC,EAASzD,QADR,EAEiCmC,EAAkBsB,EAASzD,OAAQA,GAA7FyC,EAFyB,EAEzBA,eAAgBJ,EAFS,EAETA,gBAAiBc,EAFR,EAEQA,qBACzCM,EAASC,YAAcjB,EACvBmB,EAAMxD,KAAKqD,GACXA,EAAW,CACTC,YAAa,KACb1D,OAAQA,EACR2C,YAAaQ,EACbQ,SAAUtB,GAId,OADAuB,EAAMxD,KAAKqD,GACJG,EACP,MAAOC,GACP,OAAOA,ICpVIC,G,MA/CF,SAAC,GAAiD,IAAD,IAA9CC,eAA8C,SAA7BC,EAA6B,EAA7BA,KAAMC,EAAuB,EAAvBA,MACjCC,EAAsBF,EAAKN,aAAe,CAAEpB,MAAO,EAAGC,IAAK,GACzD4B,EAAgBH,EAAKhE,OAAOqB,KAAI,SAACC,EAAOpB,GAAR,MAAe,CAAEoB,MAAOA,EAAO2C,MAAO/D,MACtEkE,EAAgBJ,EAAKL,SAAWtE,GAAQ4E,EAAM,GAAK5E,EAAOO,QAAU,QACpEyE,EAAmBL,EAAKN,YAAcrE,EAAO4E,EAAQ5E,EAAOO,QAAU,QAEtE0E,EAAY,SAAC,GAAqD,IAAnDhD,EAAkD,EAAlDA,MAAO2C,EAA2C,EAA3CA,MACtBM,EAAgBjD,EAAMtC,MAgB1B,MAf6B,kBAAlBuF,IAGPA,EADyB,IAAvBP,EAAKhE,OAAOJ,OACEkC,EAAYyC,EAAe,IAE3BzC,EAAYyC,EAAe,IAI3CN,EAAQ,GAAoC,QAA/BD,EAAKhE,OAAOiE,EAAM,GAAGjF,QACpCuF,EAAgB,IAAMA,GAEF,SAAlBA,IACFA,EAAgB,MAEI,OAAlBP,EAAKL,UAAqBM,IAAUD,EAAKL,SAASrB,MAC5C,sBAAkBpD,UAAU,WAAWsF,MAAO,CAACC,MAAOL,EAAeM,WAAY,QAAjF,SAA2FH,GAAhFN,GAEX,+BAAmBM,GAARN,IAGjBU,EAAiBR,EAAc/C,MAAM,EAAG8C,EAAoB5B,OAAOjB,IAAIiD,GACvEM,EAAkBT,EAAc/C,MAAM8C,EAAoB3B,KAAKlB,IAAIiD,GACnEO,EAAmBV,EAAc/C,MAAM8C,EAAoB5B,MAAO4B,EAAoB3B,KAAKlB,IAAIiD,GACjGZ,EAAe,6BAInB,OAHImB,EAAiBjF,OAAS,IAC5B8D,EAAe,sBAAMxE,UAAU,eAAesF,MAAO,CAACM,OAAQ,aAAeT,GAA9D,SAAkFQ,KAGjG,qBAAK3F,UAAW6E,EAAU,oBAAsB,iBAAhD,SACA,uBAAM7E,UAAU,aAAhB,UACGyF,EACAjB,EACAkB,SCxCQG,G,MATK,SAAC,GAA8C,IAA5CpC,EAA2C,EAA3CA,YAAasB,EAA8B,EAA9BA,MAC5Be,EAAmB3F,EAAQ4E,EAAS5E,EAAOO,QACjD,OACE,qBAAKV,UAAU,cAAcsF,MAAO,CAACC,MAAOO,GAA5C,SACGrC,MCmBQsC,G,MAzBM,SAAC,GAAkC,IAAhCpB,EAA+B,EAA/BA,MActB,OAAc,OAAVA,EACK,KAGL,qBAAK3E,UAAU,QAAf,SAjBkB,SAACgG,GACrB,IAAIC,EAAaD,EACjB,OAAIC,EAAWxF,MAAM,kBAAkBC,OAAS,GAKC,OAD/CuF,GADAA,EAAaA,EAAWxF,MAAM,gBAAgByF,KAAK,KAC3BC,eACTtC,OAAOoC,EAAWvF,OAAO,KACtCuF,EAAaA,EAAW/D,MAAM,EAAG+D,EAAWvF,OAAO,IAL9CuF,EAeJG,CAAczB,EAAMqB,aCkEdK,G,MAnFA,WAAO,IAAD,EACiBC,IAAMC,SAAS,IADhC,mBACZC,EADY,KACAC,EADA,OAEOH,IAAMC,SAA4B,MAFzC,mBAEZ7B,EAFY,KAELgC,EAFK,OAGOJ,IAAMC,SAAuB,MAHpC,mBAGZ5B,EAHY,KAGLgC,EAHK,KAKbC,EAAc,SAACzC,GACnBsC,EAActC,GACd,IAAM0C,EAAiB3C,EAASC,GAC5B0C,aAA0BrG,OAC5BkG,EAAS,MACTC,EAASE,KAETH,EAASG,GACTF,EAAS,QAKbL,IAAMQ,WAAU,WACdF,EAAY,yBACX,IA8CH,OACE,sBAAK5G,UAAU,SAAf,UACE,sBAAKA,UAAY,cAAjB,UACE,cAAC,EAAD,CACEF,MAAO0G,EACPzG,SAjDc,SAACG,GACrB,IAAMiE,EAAOjE,EAAM6G,OAAOjH,MAC1B8G,EAAYzC,MAIE,OAAVO,GAAkBA,EAAMhE,OAAS,EAC5BgE,EAAMxC,MAAM,GAAGC,KAAI,SAAC2C,EAAM9D,GAAP,OACxB,cAAC,EAAD,CAEEyC,YAAaqB,EAAKrB,YAClBsB,MAAO/D,GAFFA,MAMF,QAsCP,qBAAKhB,UAAY,eAAjB,SAjCY,OAAV0E,GAAmC,IAAjBA,EAAMhE,OACnB,KACY,OAAVgE,GAAkBA,EAAMhE,OAAS,EAExC,qCACE,cAAC,EAAD,CAEEmE,SAAS,EACTC,KAAMJ,EAAM,GACZK,MAAO,GAHF,GAKNL,EAAMxC,MAAM,GAAGC,KAAI,SAAC2C,EAAM9D,GAAP,OAClB,cAAC,EAAD,CAEE8D,KAAMA,EACNC,MAAO/D,EAAE,GAFJA,EAAE,SAQR,OAeP,cAAC,EAAD,CAAc2D,MAAOA,SC3EZqC,G,MARH,WACV,OACE,qBAAKhH,UAAU,MAAf,SACE,cAAC,EAAD,QCFNiH,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.1bb2e2b6.chunk.js","sourcesContent":["import React from 'react';\nimport '../styles/Input.css';\n\ntype InputProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n}\n\nconst Input = ({ value, onChange }: InputProps) => {\n  return (\n    <div className='input'>\n      <input\n        type='text'\n        value={value}\n        onChange={(event: React.ChangeEvent<HTMLInputElement>): void => onChange(event)}\n      />\n    </div>\n  );\n};\n\nexport default Input;\n","const colors = [\n  '#CC0B00',\n  '#E69138',\n  '#F1C231',\n  '#6AA850',\n  '#3D85C6',\n  '#674FA7'\n];\n\nexport { colors };","// Debugging utility.\nconst formatTokens = (tokens: Token[]): string => {\n  let formatted = tokens.map((token) => token.value.toString()).join(' ')\n  formatted = formatted.split('neg (').join('-(')\n  return formatted\n}\n\nexport type TokenType = 'operator' | 'number' | 'parentheses';\nexport type TokenValue = string | number;\nexport type Token = {\n  type: TokenType,\n  value: TokenValue\n};\n\nexport type Interval = {\n  start: number,\n  end: number\n}\n\nexport type Step = {\n  tokens: Token[],\n  description: string,\n  computed: Interval | null,\n  computeNext: Interval | null\n}\n\nconst tokenizeLiteral = (literal: string): Token => {\n  if (!isNaN(Number(literal)) && literal !== '') {\n    if (literal.split('.').length === 2) {\n      return {type: 'number', value: parseFloat(literal)};\n    } else {\n      return {type: 'number', value: parseInt(literal)};\n    }\n  } else {\n    throw new Error('User Error: Literal not recognized.');\n  }\n};\n\nconst tokenize = (text: string): Token[] => {\n  let tokens: Token[] = [];\n  for (let i=0; i < text.length; i++) {\n    // Char at i is a number or \".\".\n    if (!isNaN(parseInt(text.charAt(i))) || text.charAt(i) === '.') {\n      let j = i;\n      while (j < text.length && (!isNaN(parseInt(text.charAt(j))) || text.charAt(j) === '.')) {\n        j += 1;\n      }\n      const literal = text.slice(i, j);\n      const token = tokenizeLiteral(literal);\n      tokens.push(token);\n      i = j-1;\n    // Char at i is an operator.\n    } else if ('^*/+-'.includes(text.charAt(i))) {\n      tokens.push({type: 'operator', value: text.charAt(i)});\n    } else if ('()'.includes(text.charAt(i))) {\n      tokens.push({type: 'parentheses', value: text.charAt(i)});      \n    } else if (text.charAt(i) !== ' ') {\n      throw new Error('User Error: \"' + text[i] + '\" is not a valid character.');\n    }\n  }\n  return tokens;\n};\n\n// NOT intended to handle errors.\nconst establishNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i < tokens.length; i++) {\n    // Is a candidate for conversion to \"neg\".\n    if (tokens[i].value === '-') {\n      let isNegative = true;\n      // Minus is at the end.\n      if (i+1 === tokens.length) {\n        isNegative = false;\n      // Minus is followed by an operator or \")\" (i.e. if followed by \"(\" then isNegative would remain \"true\").\n      } else if (tokens[i+1].type === 'operator' || tokens[i+1].value === ')') {\n        isNegative = false;\n      // Minus follows a number.\n      } else if (i > 0 && tokens[i-1].type === 'number') {\n        isNegative = false;\n      // Minus is followed by a number followed by an exponent sign (which operates before negative conversion).\n      } else if (i+2 < tokens.length && tokens[i+2].value === '^') {\n        isNegative = false\n      }\n\n      if (isNegative) {\n        newTokens.push({type: 'operator', value: 'neg'})\n      } else {\n        newTokens.push({type: 'operator', value: '-'})\n      }\n    // Not a candidate for conversion to \"neg\".\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value})\n    }\n  }\n  return newTokens;\n};\n\n// Only handles errors related to bad \"neg\"s.\nconst resolveNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === 'neg') {\n      // Is at the end of expression (internal because it shouldn't have been converted if at end).\n      if (i+1 >= tokens.length) {\n        throw new Error('Internal Error: Expression cannot end with a \"neg\" operator.');\n      } else {\n        const nextToken = tokens[i+1];\n        // Is followed by \"(\".\n        if (nextToken.value === '(') {\n          newTokens.push({type: 'operator', value: 'neg'});\n        // Is followed by a number.\n        } else if (typeof nextToken.value == 'number') {\n          let newValue = -1 * nextToken.value;\n          // DO NOT resolve \"neg 0\" to \"-0\".\n          if (nextToken.value === 0) {\n            newValue = 0;\n          }\n          newTokens.push({type: 'number', value: newValue});\n          i += 1;\n        // Is followed by something other than \"(\" or a number (internal because shouldn't have been converted if so).\n        } else {\n          throw new Error('Internal Error: \"neg\"s must be followed by \"(\" or a number.');\n        }\n      }\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value});\n    }\n  }\n  return newTokens;\n};\n\n// Assumes no \"neg\"s or parentheses; handles most other input logic errors.\nconst performMathOperation = (tokens: Token[]): Token[] => {\n  if (tokens.length === 1) {\n    if (tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist only of an operator.');\n    } else {\n      return [{type: 'number', value: tokens[0].value}]; \n    }\n  }\n\n  const operatorGroups: (string | number)[][] = [['^'], ['*', '/'], ['+', '-']];\n  let operatorIndex: number | undefined = undefined;\n  for (let i=0; i<operatorGroups.length; i++) {\n    let j = 0;\n    for ( ; j < tokens.length; j+=1) {\n      // If the current token matches the current operator group (eg. \"Multiplication and division\" from PEMDAS).\n      if (operatorGroups[i].includes(tokens[j].value)) {\n        operatorIndex = j;\n        break;\n      }\n    }\n    if (operatorIndex !== undefined) {\n      break;\n    }\n  };\n\n  if (operatorIndex === undefined) {\n    throw new Error('User Error: Multiple tokens in expression with no operator.');\n  } else if (operatorIndex === 0) {\n    throw new Error('User Error: Expression cannot start with an operator.');\n } else if (operatorIndex === tokens.length-1) {\n   throw new Error('User Error: Expression cannot end with an operator.');\n  }\n\n  let newToken: Token | undefined = undefined;\n\n  const leftOperand: Token = tokens[operatorIndex-1];\n  const rightOperand: Token = tokens[operatorIndex+1];\n  const operator: Token = tokens[operatorIndex];\n  if (typeof leftOperand.value === 'number' && typeof rightOperand.value === 'number') {\n    let newValue: number | undefined = undefined;\n    if (operator.value === '^') {\n      if (leftOperand.value < 0 && rightOperand.value % 1 !== 0) {\n        throw new Error('User Error: ' + leftOperand.value.toString() + '^' + rightOperand.value.toString() + ' results in an imaginary number, which is not supported.')\n      }\n      newValue = Math.pow(leftOperand.value, rightOperand.value);\n    } else if (operator.value === '*') {\n      newValue = leftOperand.value*rightOperand.value;\n    } else if (operator.value === '/') {\n      newValue = leftOperand.value/rightOperand.value;\n    } else if (operator.value === '+') {\n      newValue = leftOperand.value+rightOperand.value;\n    } else if (operator.value === '-') {\n      newValue = leftOperand.value-rightOperand.value;\n    }\n    if (newValue === undefined) {\n      throw new Error('Internal Error: \"' + operator.value + '\" operator not recognized.');\n    } else {\n      newToken = {type: 'number', value: newValue};\n    }\n  } else {\n    throw new Error('User Error: \"' + operator.value + '\" operator requires numeric operands.');\n  }\n  \n  if (newToken === undefined) {\n    throw new Error('Internal Error: performSimpleOperation function failed.');\n  } else {\n    const leftTokens = tokens.slice(0, operatorIndex-1).map((token) => ({type: token.type, value: token.value}));\n    const rightTokens = tokens.slice(operatorIndex+2).map((token) => ({type: token.type, value: token.value}));\n    const newTokens = leftTokens.concat([newToken]).concat(rightTokens);      \n    return newTokens;\n  }\n};\n\n// Only handles errors to do with parentheses.\nconst performOperation = (tokens: Token[]): Token[] => {\n  let parenStart: number | undefined = undefined;\n  let parenEnd: number | undefined = undefined;\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === '(') {\n      parenStart = i;\n    } else if (tokens[i].value === ')') {\n      parenEnd = i;\n      break;\n    }\n  }\n\n  if ((parenStart === undefined) !== (parenEnd === undefined)) {\n    throw new Error('User Error: Mismatched parentheses.');\n  }\n\n  let newTokens: Token[] | undefined = undefined;\n\n  // We'll be working within parentheses.\n  if (parenStart !== undefined && parenEnd !== undefined) {\n    const contents: Token[] = tokens.slice(parenStart+1, parenEnd);\n    if (contents.length === 0) {\n      throw new Error('User Error: Parentheses cannot be empty.');\n    }\n    const contentsOperated = performMathOperation(contents);\n    // Contents operated contains single number.\n    if (contentsOperated.length === 1 && contentsOperated[0].type === 'number') {\n      // Remove parentheses when concatenating.\n      const leftTokens = tokens.slice(0, parenStart).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd+1).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    // Contents operated contains multiple numbers (error cases handled within perform math operation).\n    } else {\n      const leftTokens = tokens.slice(0, parenStart+1).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    }\n  // There are no parentheses remaining.\n  } else {\n    newTokens = performMathOperation(tokens);\n  }\n\n  if (newTokens !== undefined) {\n    newTokens = resolveNegatives(newTokens);\n    return newTokens;\n  } else {\n    throw new Error('Internal Error: \"performOperation\" function failed.');\n  }\n};\n\nconst formatOrdinal = (n: number): string => {\n  const nString = n.toString();\n  if (n % 1 !== 0) {\n    return nString + 'th';\n  }\n  const lastDigit = parseInt(nString.charAt(nString.length-1));\n  const truncated = n % 100;\n  let suffix = 'th';\n  if (lastDigit === 1 && truncated !== 11) {\n    suffix = 'st';\n  } else if (lastDigit === 2 && truncated !== 12) {\n    suffix = 'nd';\n  } else if (lastDigit === 3 && truncated !== 13) {\n    suffix = 'rd';\n  }\n  return nString + suffix;\n}\n\nconst formatFloat = (number: number, digits: number): string => {\n  let formatted: number | string = number;\n  // Using workaround to assess digits after decimal, as  \"3.1 % 1\" yields \"0.1000000000000000001\" (not what we want).\n  if (formatted % 1 !== 0 && formatted.toString().split('.')[1].length > digits) {\n    formatted = parseFloat(number.toFixed(digits)).toString() + '...';\n  } else {\n    formatted = number.toString();\n  }\n  return formatted;\n}\n\n// Awkward, but easier & simpler than tracking and passing changes through all of the index-changing operations (math operations, resolving parentheses, resolving negatives).\n// Assumes both sequences describe valid equations.\nconst describeOperation = (prevTokens: Token[], newTokens: Token[]): { operationInput: Interval, operationOutput: Interval, operationDescription: string } => {\n  let i = prevTokens.length-1;\n  let j = newTokens.length-1;\n  // Move along both sets of tokens, iterating backward to ensure that i hits the first operator in cases like \"1*1*1\" to \"1*1\".\n  while (i >= 0 && j >= 0 && prevTokens[i].value === newTokens[j].value) {\n    i -= 1;\n    j -= 1;\n  }\n\n  // Case where input and output share ending numbers (eg. \"1*1+1\" to \"1+1\") so i continued 1 too far, on to the operator that was resolved.\n    // I believe all remaining cases leave i and j at the end of the input & output sequences.\n    // Including \"(1)\", where there is no operator; and \"1*1*1\" to \"1*1\", where j hits the end of the array.\n  if (prevTokens[i].type === 'operator') {\n    i += 1;\n    j += 1;\n  }\n  const operationOutput: Interval = {\n    start: j,\n    end: j+1\n  };\n  let k = i;\n  // Cases with inputs like \"(1)\", \"(1+1)\", \"neg(1)\", \"neg(1+1)\".\n  if (prevTokens[i].value === ')') {\n    while (k >= 0 && prevTokens[k].value !== '(') {\n      k -= 1;\n    }\n    if (k > 0 && prevTokens[k-1].value === 'neg') {\n      k -= 1;\n    }\n  // Cases with inputs like \"1+1\".\n  } else {\n    k -= 2;\n  }\n  const operationInput: Interval = {\n    start: k,\n    end: i+1\n  }\n  const inputTokens = prevTokens.slice(k, i+1);\n\n  let operatorIndex = 0;\n  for ( ; operatorIndex < inputTokens.length; operatorIndex++) {\n    const token = inputTokens[operatorIndex];\n    if (token.type === 'operator' && token.value !== 'neg') {\n      break;\n    }\n  }\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n  }\n\n  let description: string | undefined = undefined;\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n    throw new Error('Internal Error: \"describeOperation\" function recieved a misplaced operator.');\n  // No operator in expression (eg. \"(1)\" to \"1\").\n  } else if (operatorIndex === inputTokens.length) {\n    description = 'resolve parentheses';\n  } else if (operatorIndex < inputTokens.length) {\n    const leftOperand = inputTokens[operatorIndex-1].value;\n    const rightOperand = inputTokens[operatorIndex+1].value;\n    if (typeof leftOperand !== 'number' || typeof rightOperand !== 'number') {\n      throw new Error('Internal Error: \"describeOperation\" function received invalid operands.');\n    }\n    if (inputTokens[operatorIndex].value === '^') {\n      description = 'raise ' + formatFloat(leftOperand, 3) + ' to the ' + formatOrdinal(rightOperand) + ' power';\n    } else if (inputTokens[operatorIndex].value === '*') {\n      description = 'multiply ' + formatFloat(leftOperand, 3) + ' by ' + formatFloat(rightOperand, 3);\n    } else if (inputTokens[operatorIndex].value === '/') {\n      description = 'divide ' + formatFloat(leftOperand, 3) + ' by ' + formatFloat(rightOperand, 3);\n    } else if (inputTokens[operatorIndex].value === '+') {\n      description = 'add ' + formatFloat(rightOperand, 3) + ' to ' + formatFloat(leftOperand, 3);\n    } else if (inputTokens[operatorIndex].value === '-') {\n      description = 'subtract ' + formatFloat(rightOperand, 3) + ' from ' + formatFloat(leftOperand, 3);\n    }  \n  } else {\n\n  }\n  if (description === undefined) {\n    throw new Error('Internal Error: function \"describeOperation\" failed.');\n  }\n  return {\n    operationInput: operationInput,\n    operationOutput: operationOutput,\n    operationDescription: description\n  };\n};\n\nconst evaluate = (text: string): Step[] | Error => {\n  try {\n    let tokens = tokenize(text);\n    tokens = establishNegatives(tokens);\n    tokens = resolveNegatives(tokens);\n    if (tokens.length === 0) {\n      return [];\n    } else if (tokens.length === 1 && tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist of a single operator.');\n    }\n    let prevStep: Step = {\n      tokens: tokens,\n      description: '[Initial description.]',\n      computeNext: null,\n      computed: null,\n    };\n    const steps: Step[] = [];\n    while (prevStep.tokens.length > 1) {\n      const tokens = performOperation(prevStep.tokens);\n      const { operationInput, operationOutput, operationDescription } = describeOperation(prevStep.tokens, tokens);\n      prevStep.computeNext = operationInput;\n      steps.push(prevStep);\n      prevStep = {\n        computeNext: null,\n        tokens: tokens,\n        description: operationDescription,\n        computed: operationOutput\n      }\n    }\n    steps.push(prevStep);\n    return steps;\n  } catch (error) {\n    return error;\n  }\n};\n\nexport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performMathOperation,\n  performOperation,\n  describeOperation,\n  evaluate,\n  formatTokens,\n  formatFloat\n};","import React from 'react';\nimport { colors } from '../constants';\nimport { formatFloat } from '../solve';\nimport type { Token, Step as StepType } from '../solve';\nimport '../styles/Step.css';\n\ntype StepProps = {\n  initial?: boolean,\n  step: StepType,\n  index: number\n}\n\ntype IndexedToken = {\n  token: Token,\n  index: number\n}\n\nconst Step = ({ initial = false, step, index }: StepProps) => {\n  let computeNextInterval = step.computeNext || { start: 0, end: 0 };\n  const indexedTokens = step.tokens.map((token, i) => ({ token: token, index: i }));\n  const computedColor = step.computed ? colors[(index-1) % colors.length] : 'white';\n  const computeNextColor = step.computeNext ? colors[index % colors.length] : 'white';\n\n  const mapTokens = ({ token, index }: IndexedToken): React.ReactNode => {\n    let adjustedValue = token.value;\n    if (typeof adjustedValue === 'number') {\n      // Display more of decimal portion if it's the final result.\n      if (step.tokens.length === 1) {\n        adjustedValue = formatFloat(adjustedValue, 10);\n      } else {\n        adjustedValue = formatFloat(adjustedValue, 3);\n      }\n    }\n\n    if (index > 0 && step.tokens[index-1].value !== 'neg') {\n      adjustedValue = ' ' + adjustedValue;\n    }\n    if (adjustedValue === ' neg') {\n      adjustedValue = ' -';\n    }\n    if (step.computed !== null && index === step.computed.start) {\n      return (<span key={index} className='computed' style={{color: computedColor, fontWeight: 'bold'}}>{adjustedValue}</span>);\n    } else {\n      return (<span key={index}>{adjustedValue}</span>);\n    }\n  };\n  const preComputeNext = indexedTokens.slice(0, computeNextInterval.start).map(mapTokens);\n  const postComputeNext = indexedTokens.slice(computeNextInterval.end).map(mapTokens);\n  const computeNextInner = indexedTokens.slice(computeNextInterval.start, computeNextInterval.end).map(mapTokens);\n  let computeNext = (<></>)\n  if (computeNextInner.length > 0) {\n    computeNext = (<span className='compute-next' style={{border: '2px solid ' + computeNextColor}}>{computeNextInner}</span>)\n  }\n  return (\n    <div className={initial ? 'step step-initial' : 'step step-next'}>\n    <span className='expression'>\n      {preComputeNext}\n      {computeNext}\n      {postComputeNext}\n    </span>\n    </div>\n  );\n};\n\nexport default Step;\n","import React from 'react';\nimport { colors } from '../constants';\nimport '../styles/Description.css';\n\ntype DescriptionProps = {\n  description: string,\n  index: number\n}\n\nconst Description = ({ description, index }: DescriptionProps) => {\n  const descriptionColor = colors[(index) % colors.length];\n  return (\n    <div className='description' style={{color: descriptionColor}}>\n      {description}\n    </div>\n  );\n};\n\nexport default Description;\n","import React from 'react';\nimport '../styles/ErrorMessage.css';\n\ntype ErrorMessageProps = {\n  error: Error | null,\n}\n\nconst ErrorMessage = ({ error }: ErrorMessageProps) => {\n  const softenMessage = (message: string) => {\n    let newMessage = message;\n    if (newMessage.split('Internal Error').length > 1) {\n      return newMessage;\n    } else {\n      newMessage = newMessage.split('User Error: ').join('');\n      newMessage = newMessage.toLowerCase();\n      if (newMessage.charAt(newMessage.length-1) === '.') {\n        newMessage = newMessage.slice(0, newMessage.length-1);\n      }\n      return newMessage;\n    }\n  }\n  if (error === null) {\n    return null;\n  } else {\n    return (\n      <div className='error'>\n        {softenMessage(error.message)}\n      </div>\n    );\n  }\n};\n\nexport default ErrorMessage;\n","import React from 'react';\nimport Input from './Input';\nimport Step from './Step';\nimport Description from './Description';\nimport ErrorMessage from './ErrorMessage';\nimport { evaluate } from '../solve';\nimport type { Step as StepType } from '../solve';\nimport '../styles/Solver.css';\n\nconst Solver = () => {\n  const [expression, setExpression] = React.useState('');\n  const [steps, setSteps] = React.useState<StepType[] | null>(null)\n  const [error, setError] = React.useState<Error | null>(null);\n\n  const updateState = (text: string) => {\n    setExpression(text);\n    const evaluateResult = evaluate(text);\n    if (evaluateResult instanceof Error) {\n      setSteps(null);\n      setError(evaluateResult);\n    } else {\n      setSteps(evaluateResult);\n      setError(null);\n    };\n  }\n\n  // Call once at start to sync expression, steps, error.\n  React.useEffect(() => {\n    updateState('1-2+-(4/2-1.5)^-3*2');\n  }, [])\n\n  const onInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    const text = event.target.value;\n    updateState(text);\n  };\n\n  const getDescriptions = () => {\n    if (steps !== null && steps.length > 1) {\n      return steps.slice(1).map((step, i) => (\n        <Description\n          key={i}\n          description={step.description}\n          index={i}\n        />\n      ));\n    } else {\n      return null;\n    }\n  }\n\n  const getSteps = () => {\n    if (steps !== null && steps.length === 0) {\n      return null;\n    } else if (steps !== null && steps.length > 0) {\n      return (\n        <>\n          <Step\n            key={0}\n            initial={true}\n            step={steps[0]}\n            index={0}\n            />\n          {steps.slice(1).map((step, i) => (\n            <Step\n              key={i+1}\n              step={step}\n              index={i+1}\n            />\n          ))}\n       </>\n      );\n    } else {\n      return null;\n    }\n  }\n  return (\n    <div className='solver'>\n      <div className = 'solver-left'>\n        <Input\n          value={expression}\n          onChange={onInputChange}\n        />\n        {getDescriptions()}\n      </div>\n      <div className = 'solver-right'>\n        {getSteps()}\n      </div>\n      <ErrorMessage error={error} />\n    </div>\n  );\n};\n\nexport default Solver;\n","import React from 'react';\nimport Solver from './Solver';\nimport '../styles/App.css';\n\nconst App = () => {\n  return (\n    <div className='app'>\n      <Solver />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}