{"version":3,"sources":["components/Input.tsx","components/Step.tsx","components/Description.tsx","solve.ts","components/Solver.tsx","components/App.tsx","index.tsx"],"names":["Input","value","onChange","className","type","event","Step","initial","Description","formatTokens","tokens","formatted","map","token","toString","join","split","tokenizeLiteral","literal","includes","isNaN","parseFloat","parseInt","resolveNegatives","newTokens","i","length","push","nextToken","performSimpleOperation","tokenValues","operators","operatorIndex","indexOf","newToken","undefined","leftOperand","rightOperand","operator","console","log","newType","newValue","Math","pow","leftTokens","slice","rightTokens","concat","performOperation","parenStart","parenEnd","contents","contentsOperated","evaluate","text","charAt","j","tokenize","isNegative","establishNegatives","steps","Solver","React","useState","expression","setExpression","target","forEach","step","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ea02dfb6.chunk.js","sourcesContent":["import React from 'react';\nimport '../styles/Input.css';\n\ntype InputProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n}\n\nconst Input = ({ value, onChange }: InputProps) => {\n  return (\n    <div className='input'>\n      <input\n        type='text'\n        value={value}\n        onChange={(event: React.ChangeEvent<HTMLInputElement>): void => onChange(event)}\n      />\n    </div>\n  );\n};\n\nexport default Input;\n","import React from 'react';\nimport '../styles/Step.css';\n\ntype StepProps = {\n  initial?: boolean,\n}\nconst Step = ({ initial }: StepProps) => {\n  return (\n    <div className={initial ? 'step step-initial' : 'step step-next'}>\n    </div>\n  );\n};\n\nexport default Step;\n","import React from 'react';\nimport '../styles/Description.css';\n\nconst Description = () => {\n  return (\n    <div className='description'>\n    </div>\n  );\n};\n\nexport default Description;\n","// import { exception } from \"console\";\n\nconst formatTokens = (tokens: Token[]): string => {\n  let formatted = tokens.map((token) => token.value.toString()).join(' ')\n  formatted = formatted.split('neg (').join('- (')\n  return formatted\n}\n\ntype TokenType = 'operator' | 'integer' | 'float';\n// TODO: Figure out how to use TokenValue alias without causing problems.\n  // Problem: 'Type \"string\" is not assignable to type \"TokenValue\"'\n// type TokenValue = '(' | ')' | '^' | 'neg' | '*' | '/' | '+' | '-' | number;\ntype TokenValue = string | number;\ntype Token = {\n  type: TokenType,\n  value: TokenValue\n};\n\nconst tokenizeLiteral = (literal: string): Token | undefined => {\n  // console.log('tokenize literal: ', literal);\n  if (literal.includes('.')) {\n    if (isNaN(parseFloat(literal))) {\n      // raise Exception('User Error: Solitary \".\" is not a valid literal.')\n      return undefined\n    } else {\n      return {type: 'float', value: parseFloat(literal)};\n    }\n  } else if (!isNaN(parseInt(literal))) {\n    return {type: 'integer', value: parseInt(literal)};\n  } else {\n    // raise Exception('User Error: Literal not recognized.')\n    return undefined\n  }\n};\n\nconst tokenize = (text: string): Token[] | undefined => {\n  let tokens: Token[] = [];\n  for (let i=0; i < text.length; i++) {\n    // Char at i is a number or \".\"\n    if (!isNaN(parseInt(text.charAt(i))) || text.charAt(i) === '.') {\n      // console.log('tokenize: char at i is a number or \".\"', text.charAt(i));\n      let j = i;\n      // console.log(isNaN(parseInt(text.charAt(0))));\n      while (j < text.length && (!isNaN(parseInt(text.charAt(j))) || text.charAt(j) === '.')) {\n        // console.log('tokenize: inside while', text, text.charAt(j));\n        j += 1;\n      }\n      const literal = text.slice(i, j);\n      // console.log('tokenize: i j', i, j);\n      const token = tokenizeLiteral(literal);\n      if (token) {\n        tokens.push(token);\n        i = j-1;\n        // console.log('tokenize: i = j', i);\n      } else {\n        // console.log('tokenize: tokenize literal returned undefined');\n        // Internal Error: tokenize literal returned undefined.\n        return undefined;\n      }\n    } else if (['(', ')', '^', '*', '/', '+', '-'].includes(text.charAt(i))) {\n      // console.log('tokenize: operators includes char')\n      const token: Token = {type: 'operator', value: text.charAt(i)}\n      tokens.push(token);\n    } else if (text.charAt(i) !== ' ') {\n      // raise Exception('User Error: \"' + text[i] + '\" is not a valid character.')\n      return undefined;\n    }\n  }\n  // console.log('tokenize: returning', tokens);\n  return tokens;\n};\n\n// NOT intended to handle errors.\nconst establishNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i < tokens.length; i++) {\n    // Is a candidate for conversion to \"neg\".\n    if (tokens[i].value === '-') {\n      let isNegative = true;\n      // Minus is at the end.\n      if (i+1 === tokens.length) {\n        isNegative = false;\n      // Minus is followed by an operator other than \"(\".\n      } else if (tokens[i+1].type === 'operator' && tokens[i+1].value !== '(') {\n        isNegative = false;\n      // Minus follows a number.\n      } else if (i > 0 && ['integer', 'float'].includes(tokens[i-1].type)) {\n        isNegative = false;\n      // Minus is followed by a number followed by an exponent sign (which operates before negative conversion).\n      } else if (i+2 < tokens.length && tokens[i+2].value === '^') {\n        isNegative = false\n      }\n\n      if (isNegative) {\n        newTokens.push({type: 'operator', value: 'neg'})\n      } else {\n        newTokens.push({type: 'operator', value: '-'})\n      }\n    // Not a candidate for conversion for \"neg\".\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value})\n    }\n  }\n  return newTokens;\n};\n\n// Only handles errors related to bad \"neg\"s.\nconst resolveNegatives = (tokens: Token[]): Token[] | undefined => {\n  let newTokens: Token[] = [];\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === 'neg') {\n      // Is at the end of expression (internal because it shouldn't have been converted if at end).\n      if (i+1 >= tokens.length) {\n        // raise Exception('Internal Error: Expression cannot end with a \"neg\".')\n        return undefined\n      // Is followed by \"(\".\n      } else if (tokens[i+1].value === '(') {\n        newTokens.push({type: 'operator', value: 'neg'});\n      // Is followed by a number.\n      } else if (['integer', 'float'].includes(tokens[i+1].type)) {\n        // Doing this to narrow tokens[i+1].value type.\n        const nextToken = tokens[i+1];\n        if (typeof nextToken.value === 'number') {\n          newTokens.push({type: nextToken.type, value: -1*nextToken.value});\n        } // Else something has gone terribly wrong...\n        i += 1;\n      // Is followed by something other than \"(\" or a number (internal because shouldn't have been converted if so).\n      } else {\n        // raise Exception('Internal Error: \"Neg\"s must be followed by \"(\" or a number.')\n        return undefined\n      }\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value});\n    }\n  }\n  return newTokens;\n};\n\n// Assumes no \"neg\"s or parentheses.\nconst performSimpleOperation = (tokens: Token[]): Token[] | undefined => {\n  // console.log('perform simple operation: tokens at start', formatTokens(tokens));\n  if (tokens.length === 1) {\n    if (tokens[0].type === 'operator') {\n      // User Error: Expression cannot consist of an operator. (or something)\n      return undefined\n    } else {\n      return [{type: tokens[0].type, value: tokens[0].value}]; \n    }\n  }\n\n  const tokenValues: TokenValue[] = tokens.map((token) => token.value);\n  const operators = ['^', '*', '/', '+', '-'];\n  let operatorIndex = -1;\n  for (let i=0; i<operators.length; i++) {\n    if (tokenValues.includes(operators[i])) {\n      operatorIndex = tokenValues.indexOf(operators[i]);\n      break;\n    };\n  };\n\n  if (operatorIndex === -1) {\n    // raise Exception('User Error: Multiple tokens in expression with no operator.')\n    return undefined;\n  } else if (operatorIndex === 0) {\n    // raise Exception('User Error: Expression cannot start with operator.')\n    return undefined;\n  } else if (operatorIndex === tokens.length-1) {\n    // raise Exception('User Error: Expression cannot end with an operator.')\n    return undefined;\n  }\n  \n  let newToken: Token | undefined = undefined;\n\n  const leftOperand: Token = tokens[operatorIndex-1];\n  const rightOperand: Token = tokens[operatorIndex+1];\n  const operator: Token = tokens[operatorIndex];\n  console.log('perform simple operation: tokens, operator', formatTokens(tokens), operator);\n  if (typeof leftOperand.value === 'number' && typeof rightOperand.value === 'number') {\n    let newType: TokenType = 'integer';\n    if (leftOperand.type === 'float' || rightOperand.type === 'float') {\n      newType = 'float';\n    }\n    let newValue: number | undefined = undefined;\n    if (operator.value === '^') {\n      newValue = Math.pow(leftOperand.value, rightOperand.value);\n    } else if (operator.value === '*') {\n      newValue = leftOperand.value*rightOperand.value;\n    } else if (operator.value === '/') {\n      newValue = leftOperand.value/rightOperand.value;\n    } else if (operator.value === '+') {\n      newValue = leftOperand.value+rightOperand.value;\n    } else if (operator.value === '-') {\n      newValue = leftOperand.value-rightOperand.value;\n    }\n    if (newValue === undefined) {\n      // raise exception('Internal Error: \"' + operator['value'] + '\" operator not recognized.')\n      return undefined;\n    } else {\n      newToken = {type: newType, value: newValue};\n    }\n  } else {\n    // raise Exception('User Error: \"' + tokens[i]['value'] + '\" operator requires numeric operands.')\n    return undefined;\n  }\n  \n  if (newToken === undefined) {\n    // Internal Error: simple operation failed.\n    return undefined;\n  } else {\n    const leftTokens = tokens.slice(0, operatorIndex-1).map((token) => ({type: token.type, value: token.value}));\n    const rightTokens = tokens.slice(operatorIndex+2).map((token) => ({type: token.type, value: token.value}));\n    const newTokens = leftTokens.concat([newToken]).concat(rightTokens);      \n    // console.log('perform simple operation: info at end', operatorIndex);\n    // console.log('perform simple operation: right', formatTokens(rightTokens));\n    // console.log('perform simple operation: tokens at end', formatTokens(newTokens));\n    return newTokens;\n  }\n};\n\nconst performOperation = (tokens: Token[]): Token[] | undefined => {\n  // let newTokens: Token[] = [];\n  // return newTokens;\n  let parenStart: number | undefined = undefined;\n  let parenEnd: number | undefined = undefined;\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === '(') {\n      parenStart = i;\n    } else if (tokens[i].value === ')') {\n      parenEnd = i;\n      break;\n    }\n  }\n\n  if ((parenStart === undefined) !== (parenEnd === undefined)) {\n    // User Error: Mismatched parentheses. (or something)\n    return undefined;\n  }\n\n  let newTokens: Token[] | undefined = undefined;\n\n  // We'll be working within parentheses.\n  if (parenStart !== undefined && parenEnd !== undefined) {\n    const contents: Token[] = tokens.slice(parenStart+1, parenEnd);\n    if (contents.length === 0) {\n      // raise Exception('User Error: Parentheses cannot be empty.')\n      return undefined;\n    }\n    const contentsOperated: Token[] | undefined = performSimpleOperation(contents);\n    if (contentsOperated === undefined) {\n      // Internal Error: simple operation failed (or something).\n      return undefined;\n    }\n    // Contents operated contains single number.\n    if (contentsOperated.length === 1 && ['integer', 'float'].includes(contentsOperated[0].type)) {\n      const leftTokens = tokens.slice(0, parenStart).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd+1).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    } else {\n      const leftTokens = tokens.slice(0, parenStart+1).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    }\n  // There are no parentheses remaining.\n  } else {\n    newTokens = performSimpleOperation(tokens);\n  }\n\n  if (newTokens !== undefined) {\n    newTokens = resolveNegatives(newTokens);\n  }\n  return newTokens;\n};\n\nconst evaluate = (text: string): Token[][] | undefined => {\n  let tokens = tokenize(text);\n  if (tokens === undefined) {\n    // Internal Error: Tokenize returned undefined (or something).\n    return undefined\n  }\n  tokens = establishNegatives(tokens);\n  if (tokens === undefined) {\n    // Internal Error: Establish negatives returned undefined (or something).\n    return undefined\n  }\n  tokens = resolveNegatives(tokens);\n  if (tokens === undefined) {\n    // Internal Error: Resolve negatives returned undefined (or something).\n    return undefined\n  }\n  // console.log('evaluate: about to add first tokens to steps', tokens);\n  let steps = [tokens];\n  // const thing = history.length-1;\n  // const thang = history[thing];\n  while (steps[steps.length-1].length > 1) {\n    tokens = steps[steps.length-1];\n    tokens = performOperation(tokens);\n    if (tokens === undefined) {\n      // Internal Error: Perform operation returned undefined (or something).\n      return undefined;\n    }\n    // console.log('evaluate: about to add tokens to steps within while', tokens);\n    steps.push(tokens);\n  }\n  return steps;\n};\n\nexport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performSimpleOperation,\n  performOperation,\n  evaluate,\n  formatTokens\n};\n\n// TODO\n  // Consider refactoring tokens; it's a little redundant to have to keep checking the actual type of the number, as well as the token.type.\n  // Returns and conditionals and exceptions all over the place are leaving things a mess (especially performSimpleOperation).\n    // In theory having early returns makes it so there are guarantees down the line, but that gets messy fast.....\n  // Also idk about using \"-1\" as index default in that one place.\n  // Ya, checks and exceptions are all over the place. resolve that.\n  // ASAP make it so all these funcs can't return undefined... I'd love to remove all the narrowing for that.","import React from 'react';\nimport Input from './Input';\nimport Step from './Step';\nimport Description from './Description';\nimport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performSimpleOperation,\n  performOperation,\n  evaluate,\n  formatTokens\n} from '../solve';\nimport '../styles/Solver.css';\n\nconst Solver = () => {\n  const [expression, setExpression] = React.useState(\"\");\n\n  const onInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    const text = event.target.value;\n    // console.log(text);\n    setExpression(text);\n    const steps = evaluate(text);\n    if (steps !== undefined) {\n      steps.forEach((step) => {\n        console.log(formatTokens(step));\n      });\n    } else {\n      console.log('evaluated undefined')\n    }\n  };\n\n  return (\n    <div className='solver'>\n      <div className = 'solver-left'>\n        <Input\n          value={expression}\n          onChange={onInputChange}\n        />\n        <Description />\n        <Description />\n        <Description />\n      </div>\n      <div className='solver-middle' />\n      <div className = 'solver-right'>\n        <Step\n          initial={true}\n        />\n        <Step />\n        <Step />\n        <Step />\n      </div>\n    </div>\n  );\n};\n\nexport default Solver;\n","import React from 'react';\nimport Solver from './Solver';\nimport '../styles/App.css';\n\nconst App = () => {\n  return (\n    <div className='app'>\n      <Solver />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}