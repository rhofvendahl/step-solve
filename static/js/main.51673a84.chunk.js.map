{"version":3,"sources":["components/Input.tsx","constants.ts","components/Step.tsx","components/Description.tsx","components/ErrorMessage.tsx","solve.ts","components/Solver.tsx","components/App.tsx","index.tsx"],"names":["Input","value","onChange","className","type","event","colors","Step","initial","step","index","computeNextInterval","computeNext","start","end","indexedTokens","tokens","map","token","i","computedColor","computed","length","computeNextColor","console","log","mapTokens","adjustedValue","toString","style","color","fontWeight","preComputeNext","slice","postComputeNext","computeNextInner","border","Description","description","descriptionColor","ErrorMessage","error","message","newMessage","split","join","toLowerCase","charAt","softenMessage","formatTokens","formatted","tokenizeLiteral","literal","isNaN","Number","Error","parseFloat","parseInt","resolveNegatives","newTokens","nextToken","push","newValue","performMathOperation","tokenValues","operators","operatorIndex","includes","indexOf","undefined","newToken","leftOperand","rightOperand","operator","Math","pow","leftTokens","rightTokens","concat","performOperation","parenStart","parenEnd","contents","contentsOperated","describeOperation","prevTokens","j","operationOutput","k","operationInput","inputTokens","n","nString","lastDigit","truncated","suffix","getOrdinalString","operationDescription","evaluate","text","tokenize","isNegative","establishNegatives","prevStep","steps","Solver","React","useState","expression","setExpression","setSteps","setError","updateState","evaluateResult","forEach","useEffect","target","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"4TAoBeA,EAZD,SAAC,GAAqC,IAAnCC,EAAkC,EAAlCA,MAAOC,EAA2B,EAA3BA,SACtB,OACE,qBAAKC,UAAU,QAAf,SACE,uBACEC,KAAK,OACLH,MAAOA,EACPC,SAAU,SAACG,GAAD,OAAsDH,EAASG,SCd3EC,EAAS,CACb,UACA,UACA,UACA,UACA,UACA,WCmDaC,G,MAvCF,SAAC,GAAiD,IAAD,IAA9CC,eAA8C,SAA7BC,EAA6B,EAA7BA,KAAMC,EAAuB,EAAvBA,MACjCC,EAAsBF,EAAKG,aAAe,CAAEC,MAAO,EAAGC,IAAK,GACzDC,EAAgBN,EAAKO,OAAOC,KAAI,SAACC,EAAOC,GAAR,MAAe,CAAED,MAAOA,EAAOR,MAAOS,MACtEC,EAAgBX,EAAKY,SAAWf,GAAQI,EAAM,GAAKJ,EAAOgB,QAAU,QACpEC,EAAmBd,EAAKG,YAAcN,EAAOI,EAAQJ,EAAOgB,QAAU,QAC5EE,QAAQC,IAAIf,EAAOU,EAAeG,GAElC,IAAMG,EAAY,SAAC,GAAqD,IAAnDR,EAAkD,EAAlDA,MAAOR,EAA2C,EAA3CA,MACtBiB,EAAgBT,EAAMjB,MAAM2B,WAOhC,OANIlB,EAAQ,GAAoC,QAA/BD,EAAKO,OAAON,EAAM,GAAGT,QACpC0B,EAAgB,IAAMA,GAEF,SAAlBA,IACFA,EAAgB,MAEI,OAAlBlB,EAAKY,UAAqBX,IAAUD,EAAKY,SAASR,MAC5C,sBAAkBV,UAAU,WAAW0B,MAAO,CAACC,MAAOV,EAAeW,WAAY,QAAjF,SAA2FJ,GAAhFjB,GAEX,+BAAmBiB,GAARjB,IAGjBsB,EAAiBjB,EAAckB,MAAM,EAAGtB,EAAoBE,OAAOI,IAAIS,GACvEQ,EAAkBnB,EAAckB,MAAMtB,EAAoBG,KAAKG,IAAIS,GACnES,EAAmBpB,EAAckB,MAAMtB,EAAoBE,MAAOF,EAAoBG,KAAKG,IAAIS,GACjGd,EAAe,6BAInB,OAHIuB,EAAiBb,OAAS,IAC5BV,EAAe,sBAAMT,UAAU,eAAe0B,MAAO,CAACO,OAAQ,aAAeb,GAA9D,SAAkFY,KAGjG,qBAAKhC,UAAWK,EAAU,oBAAsB,iBAAhD,SACA,uBAAML,UAAU,aAAhB,UACG6B,EACApB,EACAsB,SCjCQG,G,MATK,SAAC,GAA8C,IAA5CC,EAA2C,EAA3CA,YAAa5B,EAA8B,EAA9BA,MAC5B6B,EAAmBjC,EAAQI,EAASJ,EAAOgB,QACjD,OACE,qBAAKnB,UAAU,cAAc0B,MAAO,CAACC,MAAOS,GAA5C,SACGD,MCmBQE,G,MAzBM,SAAC,GAAkC,IAAhCC,EAA+B,EAA/BA,MActB,OAAc,OAAVA,EACK,KAGL,qBAAKtC,UAAU,QAAf,SAjBkB,SAACuC,GACrB,IAAIC,EAAaD,EACjB,OAAIC,EAAWC,MAAM,kBAAkBtB,OAAS,GAKC,OAD/CqB,GADAA,EAAaA,EAAWC,MAAM,gBAAgBC,KAAK,KAC3BC,eACTC,OAAOJ,EAAWrB,OAAO,KACtCqB,EAAaA,EAAWV,MAAM,EAAGU,EAAWrB,OAAO,IAL9CqB,EAeJK,CAAcP,EAAMC,aC1BvBO,EAAe,SAACjC,GACpB,IAAIkC,EAAYlC,EAAOC,KAAI,SAACC,GAAD,OAAWA,EAAMjB,MAAM2B,cAAYiB,KAAK,KAEnE,OADAK,EAAYA,EAAUN,MAAM,SAASC,KAAK,OAuBtCM,EAAkB,SAACC,GACvB,GAAKC,MAAMC,OAAOF,KAAyB,KAAZA,EAO7B,MAAM,IAAIG,MAAM,uCANhB,OAAkC,IAA9BH,EAAQR,MAAM,KAAKtB,OACd,CAAClB,KAAM,SAAUH,MAAOuD,WAAWJ,IAEnC,CAAChD,KAAM,SAAUH,MAAOwD,SAASL,KAkExCM,EAAmB,SAAC1C,GAExB,IADA,IAAI2C,EAAqB,GAChBxC,EAAE,EAAGA,EAAEH,EAAOM,OAAQH,IAC7B,GAAwB,QAApBH,EAAOG,GAAGlB,MAAiB,CAE7B,GAAIkB,EAAE,GAAKH,EAAOM,OAChB,MAAM,IAAIiC,MAAM,gEAEhB,IAAMK,EAAY5C,EAAOG,EAAE,GAE3B,GAAwB,MAApByC,EAAU3D,MACZ0D,EAAUE,KAAK,CAACzD,KAAM,WAAYH,MAAO,YAEpC,IAA8B,iBAAnB2D,EAAU3D,MAU1B,MAAM,IAAIsD,MAAM,+DAThB,IAAIO,GAAY,EAAIF,EAAU3D,MAEN,IAApB2D,EAAU3D,QACZ6D,EAAW,GAEbH,EAAUE,KAAK,CAACzD,KAAM,SAAUH,MAAO6D,IACvC3C,GAAK,QAOTwC,EAAUE,KAAK,CAACzD,KAAMY,EAAOG,GAAGf,KAAMH,MAAOe,EAAOG,GAAGlB,QAG3D,OAAO0D,GAIHI,EAAuB,SAAC/C,GAC5B,GAAsB,IAAlBA,EAAOM,OAAc,CACvB,GAAuB,aAAnBN,EAAO,GAAGZ,KACZ,MAAM,IAAImD,MAAM,8DAEhB,MAAO,CAAC,CAACnD,KAAM,SAAUH,MAAOe,EAAO,GAAGf,QAO9C,IAHA,IAAM+D,EAA4BhD,EAAOC,KAAI,SAACC,GAAD,OAAWA,EAAMjB,SACxDgE,EAAY,CAAC,IAAK,IAAK,IAAK,IAAK,KACnCC,GAAqC,EAChC/C,EAAE,EAAGA,EAAE8C,EAAU3C,OAAQH,IAChC,GAAI6C,EAAYG,SAASF,EAAU9C,IAAK,CACtC+C,EAAgBF,EAAYI,QAAQH,EAAU9C,IAC9C,MAIJ,QAAsBkD,IAAlBH,EACF,MAAM,IAAIX,MAAM,+DACX,GAAsB,IAAlBW,EACT,MAAM,IAAIX,MAAM,yDACZ,GAAIW,IAAkBlD,EAAOM,OAAO,EACzC,MAAM,IAAIiC,MAAM,uDAGjB,IAAIe,OAA8BD,EAE5BE,EAAqBvD,EAAOkD,EAAc,GAC1CM,EAAsBxD,EAAOkD,EAAc,GAC3CO,EAAkBzD,EAAOkD,GAC/B,GAAiC,kBAAtBK,EAAYtE,OAAoD,kBAAvBuE,EAAavE,MAsB/D,MAAM,IAAIsD,MAAM,gBAAkBkB,EAASxE,MAAQ,yCArBnD,IAAI6D,OAA+BO,EACnC,GAAuB,MAAnBI,EAASxE,MAAe,CAC1B,GAAIsE,EAAYtE,MAAQ,GAAKuE,EAAavE,MAAQ,IAAM,EACtD,MAAM,IAAIsD,MAAM,eAAiBgB,EAAYtE,MAAM2B,WAAa,IAAM4C,EAAavE,MAAM2B,WAAa,4DAExGkC,EAAWY,KAAKC,IAAIJ,EAAYtE,MAAOuE,EAAavE,WACxB,MAAnBwE,EAASxE,MAClB6D,EAAWS,EAAYtE,MAAMuE,EAAavE,MACd,MAAnBwE,EAASxE,MAClB6D,EAAWS,EAAYtE,MAAMuE,EAAavE,MACd,MAAnBwE,EAASxE,MAClB6D,EAAWS,EAAYtE,MAAMuE,EAAavE,MACd,MAAnBwE,EAASxE,QAClB6D,EAAWS,EAAYtE,MAAMuE,EAAavE,OAE5C,QAAiBoE,IAAbP,EACF,MAAM,IAAIP,MAAM,oBAAsBkB,EAASxE,MAAQ,8BAQ3D,QAAiBoE,KANbC,EAAW,CAAClE,KAAM,SAAUH,MAAO6D,IAOrC,MAAM,IAAIP,MAAM,2DAEhB,IAAMqB,EAAa5D,EAAOiB,MAAM,EAAGiC,EAAc,GAAGjD,KAAI,SAACC,GAAD,MAAY,CAACd,KAAMc,EAAMd,KAAMH,MAAOiB,EAAMjB,UAC9F4E,EAAc7D,EAAOiB,MAAMiC,EAAc,GAAGjD,KAAI,SAACC,GAAD,MAAY,CAACd,KAAMc,EAAMd,KAAMH,MAAOiB,EAAMjB,UAElG,OADkB2E,EAAWE,OAAO,CAACR,IAAWQ,OAAOD,IAOrDE,EAAmB,SAAC/D,GAGxB,IAFA,IAAIgE,OAAiCX,EACjCY,OAA+BZ,EAC1BlD,EAAE,EAAGA,EAAEH,EAAOM,OAAQH,IAC7B,GAAwB,MAApBH,EAAOG,GAAGlB,MACZ+E,EAAa7D,OACR,GAAwB,MAApBH,EAAOG,GAAGlB,MAAe,CAClCgF,EAAW9D,EACX,MAIJ,QAAoBkD,IAAfW,UAA4CX,IAAbY,GAClC,MAAM,IAAI1B,MAAM,uCAGlB,IAAII,OAAiCU,EAGrC,QAAmBA,IAAfW,QAAyCX,IAAbY,EAAwB,CACtD,IAAMC,EAAoBlE,EAAOiB,MAAM+C,EAAW,EAAGC,GACrD,GAAwB,IAApBC,EAAS5D,OACX,MAAM,IAAIiC,MAAM,4CAElB,IAAM4B,EAAmBpB,EAAqBmB,GAE9C,GAAgC,IAA5BC,EAAiB7D,QAA6C,WAA7B6D,EAAiB,GAAG/E,KAAmB,CAE1E,IAAMwE,EAAa5D,EAAOiB,MAAM,EAAG+C,GAAY/D,KAAI,SAACC,GAAD,MAAY,CAACd,KAAMc,EAAMd,KAAMH,MAAOiB,EAAMjB,UACzF4E,EAAc7D,EAAOiB,MAAMgD,EAAS,GAAGhE,KAAI,SAACC,GAAD,MAAY,CAACd,KAAMc,EAAMd,KAAMH,MAAOiB,EAAMjB,UAC7F0D,EAAYiB,EAAWE,OAAOK,GAAkBL,OAAOD,OAElD,CACL,IAAMD,EAAa5D,EAAOiB,MAAM,EAAG+C,EAAW,GAAG/D,KAAI,SAACC,GAAD,MAAY,CAACd,KAAMc,EAAMd,KAAMH,MAAOiB,EAAMjB,UAC3F4E,EAAc7D,EAAOiB,MAAMgD,GAAUhE,KAAI,SAACC,GAAD,MAAY,CAACd,KAAMc,EAAMd,KAAMH,MAAOiB,EAAMjB,UAC3F0D,EAAYiB,EAAWE,OAAOK,GAAkBL,OAAOD,SAIzDlB,EAAYI,EAAqB/C,GAGnC,QAAkBqD,IAAdV,EAEF,OADAA,EAAYD,EAAiBC,GAG7B,MAAM,IAAIJ,MAAM,wDAwBd6B,EAAoB,SAACC,EAAqB1B,GAI9C,IAHA,IAAIxC,EAAIkE,EAAW/D,OAAO,EACtBgE,EAAI3B,EAAUrC,OAAO,EAElBH,GAAK,GAAKmE,GAAK,GAAKD,EAAWlE,GAAGlB,QAAU0D,EAAU2B,GAAGrF,OAC9DkB,GAAK,EACLmE,GAAK,EAMoB,aAAvBD,EAAWlE,GAAGf,MAA+C,MAAxBiF,EAAWlE,GAAGlB,QACrDkB,GAAK,EACLmE,GAAK,GAEP,IAAMC,EAA4B,CAChC1E,MAAOyE,EACPxE,IAAKwE,EAAE,GAELE,EAAIrE,EAER,GAA4B,MAAxBkE,EAAWlE,GAAGlB,MAAe,CAC/B,KAAOuF,GAAK,GAA6B,MAAxBH,EAAWG,GAAGvF,OAC7BuF,GAAK,EAEHA,EAAI,GAA+B,QAA1BH,EAAWG,EAAE,GAAGvF,QAC3BuF,GAAK,QAIPA,GAAK,EASP,IAPA,IAAMC,EAA2B,CAC/B5E,MAAO2E,EACP1E,IAAKK,EAAE,GAEHuE,EAAcL,EAAWpD,MAAMuD,EAAGrE,EAAE,GAEtC+C,EAAgB,EACZA,EAAgBwB,EAAYpE,OAAQ4C,IAAiB,CAC3D,IAAMhD,EAAQwE,EAAYxB,GAC1B,GAAmB,aAAfhD,EAAMd,MAA8C,kBAAhBc,EAAMjB,QAAuB,CAAC,MAAO,IAAK,KAAKkE,SAASjD,EAAMjB,OACpG,MAGkB,IAAlBiE,GAAyCwB,EAAYpE,OAGzD,IAAIgB,OAAkC+B,EAItC,GAHA7C,QAAQC,IAAI,sBACZD,QAAQC,IAAI,eAAgBwB,EAAayC,IACzClE,QAAQC,IAAI,iBAAkByC,GACR,IAAlBA,GAAuBA,IAAkBwB,EAAYpE,OAAO,EAC9D,MAAM,IAAIiC,MAAM,+EAEX,GAAIW,IAAkBwB,EAAYpE,OACvCgB,EAAc,2BACT,GAAI4B,EAAgBwB,EAAYpE,OAAQ,CAC7C,IAAMiD,EAAcmB,EAAYxB,EAAc,GAAGjE,MAC3CuE,EAAekB,EAAYxB,EAAc,GAAGjE,MAClD,GAA2B,kBAAhBsE,GAAoD,kBAAjBC,EAC5C,MAAM,IAAIjB,MAAM,2EAEuB,MAArCmC,EAAYxB,GAAejE,MAC7BqC,EAAc,SAAWoD,EAAYxB,EAAc,GAAGjE,MAAM2B,WAAa,WArFtD,SAAC+D,GACxB,IAAMC,EAAUD,EAAE/D,WAClB,GAAI+D,EAAI,IAAM,EACZ,OAAOC,EAAU,KAEnB,IAAMC,EAAYpC,SAASmC,EAAQ7C,OAAO6C,EAAQtE,OAAO,IACnDwE,EAAYH,EAAI,IAClBI,EAAS,KAQb,OAPkB,IAAdF,GAAiC,KAAdC,EACrBC,EAAS,KACc,IAAdF,GAAiC,KAAdC,EAC5BC,EAAS,KACc,IAAdF,GAAiC,KAAdC,IAC5BC,EAAS,MAEJH,EAAUG,EAsEyEC,CAAiBxB,GAAgB,SACzE,MAArCkB,EAAYxB,GAAejE,MACpCqC,EAAc,YAAcoD,EAAYxB,EAAc,GAAGjE,MAAM2B,WAAa,OAAS8D,EAAYxB,EAAc,GAAGjE,MAAM2B,WAC1E,MAArC8D,EAAYxB,GAAejE,MACpCqC,EAAc,UAAYoD,EAAYxB,EAAc,GAAGjE,MAAM2B,WAAa,OAAS8D,EAAYxB,EAAc,GAAGjE,MAAM2B,WACxE,MAArC8D,EAAYxB,GAAejE,MACpCqC,EAAc,OAASoD,EAAYxB,EAAc,GAAGjE,MAAM2B,WAAa,OAAS8D,EAAYxB,EAAc,GAAGjE,MAAM2B,WACrE,MAArC8D,EAAYxB,GAAejE,QACpCqC,EAAc,YAAcoD,EAAYxB,EAAc,GAAGjE,MAAM2B,WAAa,SAAW8D,EAAYxB,EAAc,GAAGjE,MAAM2B,YAK9H,QAAoByC,IAAhB/B,EACF,MAAM,IAAIiB,MAAM,wDAElB,MAAO,CACLkC,eAAgBA,EAChBF,gBAAiBA,EACjBU,qBAAsB3D,IAIpB4D,EAAW,SAACC,GAChB,IACE,IAAInF,EAlUS,SAACmF,GAEhB,IADA,IAAInF,EAAkB,GACbG,EAAE,EAAGA,EAAIgF,EAAK7E,OAAQH,IAE7B,GAAKkC,MAAMI,SAAS0C,EAAKpD,OAAO5B,MAA2B,MAAnBgF,EAAKpD,OAAO5B,IAU7C,GAAI,UAAUgD,SAASgC,EAAKpD,OAAO5B,IAAK,CAC7C,IAAMD,EAAe,CAACd,KAAM,WAAYH,MAAOkG,EAAKpD,OAAO5B,IAC3DH,EAAO6C,KAAK3C,QACP,GAAuB,MAAnBiF,EAAKpD,OAAO5B,GACrB,MAAM,IAAIoC,MAAM,gBAAkB4C,EAAKhF,GAAK,mCAdkB,CAE9D,IADA,IAAImE,EAAInE,EACDmE,EAAIa,EAAK7E,UAAY+B,MAAMI,SAAS0C,EAAKpD,OAAOuC,MAA2B,MAAnBa,EAAKpD,OAAOuC,KACzEA,GAAK,EAEP,IAAMlC,EAAU+C,EAAKlE,MAAMd,EAAGmE,GACxBpE,EAAQiC,EAAgBC,GAC9BpC,EAAO6C,KAAK3C,GACZC,EAAImE,EAAE,EASV,OAAOtE,EA6SQoF,CAASD,GAGtB,GAFAnF,EA1SuB,SAACA,GAE1B,IADA,IAAI2C,EAAqB,GAChBxC,EAAE,EAAGA,EAAIH,EAAOM,OAAQH,IAE/B,GAAwB,MAApBH,EAAOG,GAAGlB,MAAe,CAC3B,IAAIoG,GAAa,GAEblF,EAAE,IAAMH,EAAOM,QAGa,aAArBN,EAAOG,EAAE,GAAGf,MAA6C,MAAtBY,EAAOG,EAAE,GAAGlB,OAG/CkB,EAAI,GAA0B,WAArBH,EAAOG,EAAE,GAAGf,MAGrBe,EAAE,EAAIH,EAAOM,QAAgC,MAAtBN,EAAOG,EAAE,GAAGlB,SAR5CoG,GAAa,GAYXA,EACF1C,EAAUE,KAAK,CAACzD,KAAM,WAAYH,MAAO,QAEzC0D,EAAUE,KAAK,CAACzD,KAAM,WAAYH,MAAO,WAI3C0D,EAAUE,KAAK,CAACzD,KAAMY,EAAOG,GAAGf,KAAMH,MAAOe,EAAOG,GAAGlB,QAG3D,OAAO0D,EA4QI2C,CAAmBtF,GAEN,KADtBA,EAAS0C,EAAiB1C,IACfM,OACT,MAAO,GACF,GAAsB,IAAlBN,EAAOM,QAAmC,aAAnBN,EAAO,GAAGZ,KAC1C,MAAM,IAAImD,MAAM,+DASlB,IAPA,IAAIgD,EAAiB,CACnBvF,OAAQA,EACRsB,YAAa,yBACb1B,YAAa,KACbS,SAAU,MAENmF,EAAgB,GACfD,EAASvF,OAAOM,OAAS,GAAG,CACjC,IAAMN,EAAS+D,EAAiBwB,EAASvF,QADR,EAEiCoE,EAAkBmB,EAASvF,OAAQA,GAA7FyE,EAFyB,EAEzBA,eAAgBF,EAFS,EAETA,gBAAiBU,EAFR,EAEQA,qBACzCM,EAAS3F,YAAc6E,EACvBe,EAAM3C,KAAK0C,GACXA,EAAW,CACT3F,YAAa,KACbI,OAAQA,EACRsB,YAAa2D,EACb5E,SAAUkE,GAId,OADAiB,EAAM3C,KAAK0C,GACJC,EACP,MAAO/D,GACP,OAAOA,ICjRIgE,G,MArGA,WAAO,IAAD,EACiBC,IAAMC,SAAS,IADhC,mBACZC,EADY,KACAC,EADA,OAEOH,IAAMC,SAA4B,MAFzC,mBAEZH,EAFY,KAELM,EAFK,OAGOJ,IAAMC,SAAuB,MAHpC,mBAGZlE,EAHY,KAGLsE,EAHK,KAKbC,EAAc,SAACb,GACnBU,EAAcV,GACd,IAAMc,EAAiBf,EAASC,GAC5Bc,aAA0B1D,OAC5B/B,QAAQC,IAAIwF,EAAevE,SAC3BoE,EAAS,MACTC,EAASE,KAETA,EAAeC,SAAQ,SAACzG,GACtBe,QAAQC,IAAIwB,EAAaxC,EAAKO,YAEhC8F,EAASG,GACTF,EAAS,QAKbL,IAAMS,WAAU,WACdH,EAAY,sBACX,IA2DH,OACE,sBAAK7G,UAAU,SAAf,UACE,sBAAKA,UAAY,cAAjB,UACE,cAAC,EAAD,CACEF,MAAO2G,EACP1G,SA9Dc,SAACG,GACrB,IAAM8F,EAAO9F,EAAM+G,OAAOnH,MAC1B+G,EAAYb,MAIE,OAAVK,GAAkBA,EAAMlF,OAAS,EAC5BkF,EAAMvE,MAAM,GAAGhB,KAAI,SAACR,EAAMU,GAAP,OACxB,cAAC,EAAD,CAEEmB,YAAa7B,EAAK6B,YAClB5B,MAAOS,GAFFA,MAMF,QAoDP,qBAAKhB,UAAY,eAAjB,SA/CY,OAAVqG,GAAmC,IAAjBA,EAAMlF,OACnB,KACY,OAAVkF,GAAkBA,EAAMlF,OAAS,EAExC,qCACE,cAAC,EAAD,CAEEd,SAAS,EACTC,KAAM+F,EAAM,GACZ9F,MAAO,GAHF,GAKN8F,EAAMvE,MAAM,GAAGhB,KAAI,SAACR,EAAMU,GAAP,OAClB,cAAC,EAAD,CAEEV,KAAMA,EACNC,MAAOS,EAAE,GAFJA,EAAE,SAQR,OA6BP,cAAC,EAAD,CAAcsB,MAAOA,SCnGZ4E,G,MARH,WACV,OACE,qBAAKlH,UAAU,MAAf,SACE,cAAC,EAAD,QCFNmH,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.51673a84.chunk.js","sourcesContent":["import React from 'react';\nimport '../styles/Input.css';\n\ntype InputProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n}\n\nconst Input = ({ value, onChange }: InputProps) => {\n  return (\n    <div className='input'>\n      <input\n        type='text'\n        value={value}\n        onChange={(event: React.ChangeEvent<HTMLInputElement>): void => onChange(event)}\n      />\n    </div>\n  );\n};\n\nexport default Input;\n","const colors = [\n  '#CC0B00',\n  '#E69138',\n  '#F1C231',\n  '#6AA850',\n  '#3D85C6',\n  '#674FA7'\n];\n\nexport { colors };","import React from 'react';\nimport { colors } from '../constants';\n// import { formatTokens } from '../solve';\nimport type { Token, Step as StepType } from '../solve';\nimport '../styles/Step.css';\n// import { tokenToString } from 'typescript';\n\ntype StepProps = {\n  initial?: boolean,\n  step: StepType,\n  index: number\n}\n\ntype IndexedToken = {\n  token: Token,\n  index: number\n}\n\nconst Step = ({ initial = false, step, index }: StepProps) => {\n  let computeNextInterval = step.computeNext || { start: 0, end: 0 };\n  const indexedTokens = step.tokens.map((token, i) => ({ token: token, index: i }));\n  const computedColor = step.computed ? colors[(index-1) % colors.length] : 'white';\n  const computeNextColor = step.computeNext ? colors[index % colors.length] : 'white';\n  console.log(index, computedColor, computeNextColor);\n\n  const mapTokens = ({ token, index }: IndexedToken): React.ReactNode => {\n    let adjustedValue = token.value.toString();\n    if (index > 0 && step.tokens[index-1].value !== 'neg') {\n      adjustedValue = ' ' + adjustedValue;\n    }\n    if (adjustedValue === ' neg') {\n      adjustedValue = ' -';\n    }\n    if (step.computed !== null && index === step.computed.start) {\n      return (<span key={index} className='computed' style={{color: computedColor, fontWeight: 'bold'}}>{adjustedValue}</span>);\n    } else {\n      return (<span key={index}>{adjustedValue}</span>);\n    }\n  };\n  const preComputeNext = indexedTokens.slice(0, computeNextInterval.start).map(mapTokens);\n  const postComputeNext = indexedTokens.slice(computeNextInterval.end).map(mapTokens);\n  const computeNextInner = indexedTokens.slice(computeNextInterval.start, computeNextInterval.end).map(mapTokens);\n  let computeNext = (<></>)\n  if (computeNextInner.length > 0) {\n    computeNext = (<span className='compute-next' style={{border: '2px solid ' + computeNextColor}}>{computeNextInner}</span>)\n  }\n  return (\n    <div className={initial ? 'step step-initial' : 'step step-next'}>\n    <span className='expression'>\n      {preComputeNext}\n      {computeNext}\n      {postComputeNext}\n    </span>\n    </div>\n  );\n};\n\nexport default Step;\n","import React from 'react';\nimport { colors } from '../constants';\nimport '../styles/Description.css';\n\ntype DescriptionProps = {\n  description: string,\n  index: number\n}\n\nconst Description = ({ description, index }: DescriptionProps) => {\n  const descriptionColor = colors[(index) % colors.length];\n  return (\n    <div className='description' style={{color: descriptionColor}}>\n      {description}\n    </div>\n  );\n};\n\nexport default Description;\n","import React from 'react';\nimport '../styles/ErrorMessage.css';\n\ntype ErrorMessageProps = {\n  error: Error | null,\n}\n\nconst ErrorMessage = ({ error }: ErrorMessageProps) => {\n  const softenMessage = (message: string) => {\n    let newMessage = message;\n    if (newMessage.split('Internal Error').length > 1) {\n      return newMessage;\n    } else {\n      newMessage = newMessage.split('User Error: ').join('');\n      newMessage = newMessage.toLowerCase();\n      if (newMessage.charAt(newMessage.length-1) === '.') {\n        newMessage = newMessage.slice(0, newMessage.length-1);\n      }\n      return newMessage;\n    }\n  }\n  if (error === null) {\n    return null;\n  } else {\n    return (\n      <div className='error'>\n        {softenMessage(error.message)}\n      </div>\n    );\n  }\n};\n\nexport default ErrorMessage;\n","const formatTokens = (tokens: Token[]): string => {\n  let formatted = tokens.map((token) => token.value.toString()).join(' ')\n  formatted = formatted.split('neg (').join('-(')\n  return formatted\n}\n\nexport type TokenType = 'operator' | 'number';\nexport type TokenValue = string | number;\nexport type Token = {\n  type: TokenType,\n  value: TokenValue\n};\n\nexport type Interval = {\n  start: number,\n  end: number\n}\n\nexport type Step = {\n  tokens: Token[],\n  description: string,\n  computed: Interval | null,\n  computeNext: Interval | null\n}\n\nconst tokenizeLiteral = (literal: string): Token => {\n  if (!isNaN(Number(literal)) && literal !== '') {\n    if (literal.split('.').length === 2) {\n      return {type: 'number', value: parseFloat(literal)};\n    } else {\n      return {type: 'number', value: parseInt(literal)};\n    }\n  } else {\n    throw new Error('User Error: Literal not recognized.');\n  }\n};\n\nconst tokenize = (text: string): Token[] => {\n  let tokens: Token[] = [];\n  for (let i=0; i < text.length; i++) {\n    // Char at i is a number or \".\".\n    if (!isNaN(parseInt(text.charAt(i))) || text.charAt(i) === '.') {\n      let j = i;\n      while (j < text.length && (!isNaN(parseInt(text.charAt(j))) || text.charAt(j) === '.')) {\n        j += 1;\n      }\n      const literal = text.slice(i, j);\n      const token = tokenizeLiteral(literal);\n      tokens.push(token);\n      i = j-1;\n    // Char at i is an operator.\n    } else if ('()^*/+-'.includes(text.charAt(i))) {\n      const token: Token = {type: 'operator', value: text.charAt(i)}\n      tokens.push(token);\n    } else if (text.charAt(i) !== ' ') {\n      throw new Error('User Error: \"' + text[i] + '\" is not a valid character.');\n    }\n  }\n  return tokens;\n};\n\n// NOT intended to handle errors.\nconst establishNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i < tokens.length; i++) {\n    // Is a candidate for conversion to \"neg\".\n    if (tokens[i].value === '-') {\n      let isNegative = true;\n      // Minus is at the end.\n      if (i+1 === tokens.length) {\n        isNegative = false;\n      // Minus is followed by an operator other than \"(\".\n      } else if (tokens[i+1].type === 'operator' && tokens[i+1].value !== '(') {\n        isNegative = false;\n      // Minus follows a number.\n      } else if (i > 0 && tokens[i-1].type === 'number') {\n        isNegative = false;\n      // Minus is followed by a number followed by an exponent sign (which operates before negative conversion).\n      } else if (i+2 < tokens.length && tokens[i+2].value === '^') {\n        isNegative = false\n      }\n\n      if (isNegative) {\n        newTokens.push({type: 'operator', value: 'neg'})\n      } else {\n        newTokens.push({type: 'operator', value: '-'})\n      }\n    // Not a candidate for conversion to \"neg\".\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value})\n    }\n  }\n  return newTokens;\n};\n\n// Only handles errors related to bad \"neg\"s.\nconst resolveNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === 'neg') {\n      // Is at the end of expression (internal because it shouldn't have been converted if at end).\n      if (i+1 >= tokens.length) {\n        throw new Error('Internal Error: Expression cannot end with a \"neg\" operator.');\n      } else {\n        const nextToken = tokens[i+1];\n        // Is followed by \"(\".\n        if (nextToken.value === '(') {\n          newTokens.push({type: 'operator', value: 'neg'});\n        // Is followed by a number.\n        } else if (typeof nextToken.value == 'number') {\n          let newValue = -1 * nextToken.value;\n          // DO NOT resolve \"neg 0\" to \"-0\".\n          if (nextToken.value === 0) {\n            newValue = 0;\n          }\n          newTokens.push({type: 'number', value: newValue});\n          i += 1;\n        // Is followed by something other than \"(\" or a number (internal because shouldn't have been converted if so).\n        } else {\n          throw new Error('Internal Error: \"neg\"s must be followed by \"(\" or a number.');\n        }\n      }\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value});\n    }\n  }\n  return newTokens;\n};\n\n// Assumes no \"neg\"s or parentheses; handles most other input logic errors.\nconst performMathOperation = (tokens: Token[]): Token[] => {\n  if (tokens.length === 1) {\n    if (tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist only of an operator.');\n    } else {\n      return [{type: 'number', value: tokens[0].value}]; \n    }\n  }\n\n  const tokenValues: TokenValue[] = tokens.map((token) => token.value);\n  const operators = ['^', '*', '/', '+', '-'];\n  let operatorIndex: number | undefined = -1;\n  for (let i=0; i<operators.length; i++) {\n    if (tokenValues.includes(operators[i])) {\n      operatorIndex = tokenValues.indexOf(operators[i]);\n      break;\n    };\n  };\n\n  if (operatorIndex === undefined) {\n    throw new Error('User Error: Multiple tokens in expression with no operator.');\n  } else if (operatorIndex === 0) {\n    throw new Error('User Error: Expression cannot start with an operator.');\n } else if (operatorIndex === tokens.length-1) {\n   throw new Error('User Error: Expression cannot end with an operator.');\n  }\n\n  let newToken: Token | undefined = undefined;\n\n  const leftOperand: Token = tokens[operatorIndex-1];\n  const rightOperand: Token = tokens[operatorIndex+1];\n  const operator: Token = tokens[operatorIndex];\n  if (typeof leftOperand.value === 'number' && typeof rightOperand.value === 'number') {\n    let newValue: number | undefined = undefined;\n    if (operator.value === '^') {\n      if (leftOperand.value < 0 && rightOperand.value % 1 !== 0) {\n        throw new Error('User Error: ' + leftOperand.value.toString() + '^' + rightOperand.value.toString() + ' results in an imaginary number, which is not supported.')\n      }\n      newValue = Math.pow(leftOperand.value, rightOperand.value);\n    } else if (operator.value === '*') {\n      newValue = leftOperand.value*rightOperand.value;\n    } else if (operator.value === '/') {\n      newValue = leftOperand.value/rightOperand.value;\n    } else if (operator.value === '+') {\n      newValue = leftOperand.value+rightOperand.value;\n    } else if (operator.value === '-') {\n      newValue = leftOperand.value-rightOperand.value;\n    }\n    if (newValue === undefined) {\n      throw new Error('Internal Error: \"' + operator.value + '\" operator not recognized.');\n    } else {\n      newToken = {type: 'number', value: newValue};\n    }\n  } else {\n    throw new Error('User Error: \"' + operator.value + '\" operator requires numeric operands.');\n  }\n  \n  if (newToken === undefined) {\n    throw new Error('Internal error: performSimpleOperation function failed.');\n  } else {\n    const leftTokens = tokens.slice(0, operatorIndex-1).map((token) => ({type: token.type, value: token.value}));\n    const rightTokens = tokens.slice(operatorIndex+2).map((token) => ({type: token.type, value: token.value}));\n    const newTokens = leftTokens.concat([newToken]).concat(rightTokens);      \n    return newTokens;\n  }\n};\n\n// Only handles errors to do with parentheses\n// I'm thinking THIS should return a step...\nconst performOperation = (tokens: Token[]): Token[] => {\n  let parenStart: number | undefined = undefined;\n  let parenEnd: number | undefined = undefined;\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === '(') {\n      parenStart = i;\n    } else if (tokens[i].value === ')') {\n      parenEnd = i;\n      break;\n    }\n  }\n\n  if ((parenStart === undefined) !== (parenEnd === undefined)) {\n    throw new Error('User Error: Mismatched parentheses.');\n  }\n\n  let newTokens: Token[] | undefined = undefined;\n\n  // We'll be working within parentheses.\n  if (parenStart !== undefined && parenEnd !== undefined) {\n    const contents: Token[] = tokens.slice(parenStart+1, parenEnd);\n    if (contents.length === 0) {\n      throw new Error('User Error: Parentheses cannot be empty.');\n    }\n    const contentsOperated = performMathOperation(contents);\n    // Contents operated contains single number.\n    if (contentsOperated.length === 1 && contentsOperated[0].type === 'number') {\n      // Remove parentheses when concatenating.\n      const leftTokens = tokens.slice(0, parenStart).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd+1).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    // Contents operated contains multiple numbers (error cases handled within perform math operation).\n    } else {\n      const leftTokens = tokens.slice(0, parenStart+1).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    }\n  // There are no parentheses remaining.\n  } else {\n    newTokens = performMathOperation(tokens);\n  }\n\n  if (newTokens !== undefined) {\n    newTokens = resolveNegatives(newTokens);\n    return newTokens;\n  } else {\n    throw new Error('Internal Error: \"performOperation\" function failed.');\n  }\n};\n\nconst getOrdinalString = (n: number): string => {\n  const nString = n.toString();\n  if (n % 1 !== 0) {\n    return nString + 'th';\n  }\n  const lastDigit = parseInt(nString.charAt(nString.length-1));\n  const truncated = n % 100;\n  let suffix = 'th';\n  if (lastDigit === 1 && truncated !== 11) {\n    suffix = 'st';\n  } else if (lastDigit === 2 && truncated !== 12) {\n    suffix = 'nd';\n  } else if (lastDigit === 3 && truncated !== 13) {\n    suffix = 'rd';\n  }\n  return nString + suffix;\n}\n\n// Awkward, but easier & simpler than tracking and passing changes through all of the index-changing operations (math operations, resolving parentheses, resolving negatives).\n// Assumes both sequences describe valid equations.\nconst describeOperation = (prevTokens: Token[], newTokens: Token[]): { operationInput: Interval, operationOutput: Interval, operationDescription: string } => {\n  let i = prevTokens.length-1;\n  let j = newTokens.length-1;\n  // Move along both sets of tokens, iterating backward to ensure that i hits the first operator in cases like \"1*1*1\" to \"1*1\".\n  while (i >= 0 && j >= 0 && prevTokens[i].value === newTokens[j].value) {\n    i -= 1;\n    j -= 1;\n  }\n\n  // Case where input and output share ending numbers (eg. \"1*1+1\" to \"1+1\"), so i continues on to the operator that was resolved.\n    // I believe all remaining cases leave i and j at the end of the input & output sequences.\n    // Including \"(1)\", where there is no operator; and \"1*1*1\" to \"1*1\", where j hits the end of the array.\n  if (prevTokens[i].type === 'operator' && prevTokens[i].value !== ')') {\n    i += 1;\n    j += 1;\n  }\n  const operationOutput: Interval = {\n    start: j,\n    end: j+1\n  };\n  let k = i;\n  // Cases with inputs like \"(1)\", \"(1+1)\", \"neg(1)\", \"neg(1+1)\".\n  if (prevTokens[i].value === ')') {\n    while (k >= 0 && prevTokens[k].value !== '(') {\n      k -= 1;\n    }\n    if (k > 0 && prevTokens[k-1].value === 'neg') {\n      k -= 1;\n    }\n  // Cases with inputs like \"1+1\".\n  } else {\n    k -= 2;\n  }\n  const operationInput: Interval = {\n    start: k,\n    end: i+1\n  }\n  const inputTokens = prevTokens.slice(k, i+1);\n\n  let operatorIndex = 0;\n  for ( ; operatorIndex < inputTokens.length; operatorIndex++) {\n    const token = inputTokens[operatorIndex];\n    if (token.type === 'operator' && typeof token.value === 'string' && !['neg', '(', ')'].includes(token.value)) {\n      break;\n    }\n  }\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n  }\n\n  let description: string | undefined = undefined;\n  console.log('DESCRIBE OPERATION')\n  console.log('input tokens', formatTokens(inputTokens));\n  console.log('operator index', operatorIndex);\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n    throw new Error('Internal Error: \"describeOperation\" function recieved a misplaced operator.');\n  // No operator in expression (eg. \"(1)\" to \"1\").\n  } else if (operatorIndex === inputTokens.length) {\n    description = 'resolve parentheses';\n  } else if (operatorIndex < inputTokens.length) {\n    const leftOperand = inputTokens[operatorIndex-1].value;\n    const rightOperand = inputTokens[operatorIndex+1].value;\n    if (typeof leftOperand !== 'number' || typeof rightOperand !== 'number') {\n      throw new Error('Internal Error: \"describeOperation\" function received invalid operands.');\n    }\n    if (inputTokens[operatorIndex].value === '^') {\n      description = 'raise ' + inputTokens[operatorIndex-1].value.toString() + ' to the ' + getOrdinalString(rightOperand) + ' power';\n    } else if (inputTokens[operatorIndex].value === '*') {\n      description = 'multiply ' + inputTokens[operatorIndex-1].value.toString() + ' by ' + inputTokens[operatorIndex+1].value.toString();\n    } else if (inputTokens[operatorIndex].value === '/') {\n      description = 'divide ' + inputTokens[operatorIndex-1].value.toString() + ' by ' + inputTokens[operatorIndex+1].value.toString();\n    } else if (inputTokens[operatorIndex].value === '+') {\n      description = 'add ' + inputTokens[operatorIndex+1].value.toString() + ' to ' + inputTokens[operatorIndex-1].value.toString()\n    } else if (inputTokens[operatorIndex].value === '-') {\n      description = 'subtract ' + inputTokens[operatorIndex+1].value.toString() + ' from ' + inputTokens[operatorIndex-1].value.toString();\n    }  \n  } else {\n\n  }\n  if (description === undefined) {\n    throw new Error('Internal Error: function \"describeOperation\" failed.');\n  }\n  return {\n    operationInput: operationInput,\n    operationOutput: operationOutput,\n    operationDescription: description\n  };\n};\n\nconst evaluate = (text: string): Step[] | Error => {\n  try {\n    let tokens = tokenize(text);\n    tokens = establishNegatives(tokens);\n    tokens = resolveNegatives(tokens);\n    if (tokens.length === 0) {\n      return [];\n    } else if (tokens.length === 1 && tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist of a single operator.');\n    }\n    let prevStep: Step = {\n      tokens: tokens,\n      description: '[Initial description.]',\n      computeNext: null,\n      computed: null,\n    };\n    const steps: Step[] = [];\n    while (prevStep.tokens.length > 1) {\n      const tokens = performOperation(prevStep.tokens);\n      const { operationInput, operationOutput, operationDescription } = describeOperation(prevStep.tokens, tokens);\n      prevStep.computeNext = operationInput;\n      steps.push(prevStep);\n      prevStep = {\n        computeNext: null,\n        tokens: tokens,\n        description: operationDescription,\n        computed: operationOutput\n      }\n    }\n    steps.push(prevStep);\n    return steps;\n  } catch (error) {\n    return error;\n  }\n};\n\nexport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performMathOperation,\n  performOperation,\n  describeOperation,\n  evaluate,\n  formatTokens\n};\n\n// NOTE\n  // Preference is to trust token.type, with typeof used when necessary for type narrowing.\n\n// TODO\n  // Returns and conditionals and exceptions all over the place are leaving things a mess (especially performMathOperation).\n    // In theory having early returns makes it so there are guarantees down the line, but that gets messy fast.....\n  // Ya, checks and exceptions are all over the place. resolve that.\n  // Consider un-refactoring the '\"number\"' back to '\"float\" | \"integer\"', since apparently JS/TS is terrible at discerning floats/ints from numbers\n  // Consider adding \"patentheses\" type, to simplify checking for \"operation but not parentheses\".","import React from 'react';\nimport Input from './Input';\nimport Step from './Step';\nimport Description from './Description';\nimport ErrorMessage from './ErrorMessage';\nimport {\n  evaluate,\n  formatTokens\n} from '../solve';\nimport type {\n  // Token,\n  Step as StepType\n} from '../solve';\nimport '../styles/Solver.css';\n\nconst Solver = () => {\n  const [expression, setExpression] = React.useState('');\n  const [steps, setSteps] = React.useState<StepType[] | null>(null)\n  const [error, setError] = React.useState<Error | null>(null);\n\n  const updateState = (text: string) => {\n    setExpression(text);\n    const evaluateResult = evaluate(text);\n    if (evaluateResult instanceof Error) {\n      console.log(evaluateResult.message);\n      setSteps(null);\n      setError(evaluateResult);\n    } else {\n      evaluateResult.forEach((step) => {\n        console.log(formatTokens(step.tokens));\n      });\n      setSteps(evaluateResult);\n      setError(null);\n    };\n  }\n\n  // Call once at start to sync expression, steps, error.\n  React.useEffect(() => {\n    updateState('1-2+-(4/2-1)^3*2');\n  }, [])\n\n  const onInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    const text = event.target.value;\n    updateState(text);\n  };\n\n  const getDescriptions = () => {\n    if (steps !== null && steps.length > 1) {\n      return steps.slice(1).map((step, i) => (\n        <Description\n          key={i}\n          description={step.description}\n          index={i}\n        />\n      ));\n    } else {\n      return null;\n    }\n  }\n\n  const getSteps = () => {\n    if (steps !== null && steps.length === 0) {\n      return null;\n    } else if (steps !== null && steps.length > 0) {\n      return (\n        <>\n          <Step\n            key={0}\n            initial={true}\n            step={steps[0]}\n            index={0}\n            />\n          {steps.slice(1).map((step, i) => (\n            <Step\n              key={i+1}\n              step={step}\n              index={i+1}\n            />\n          ))}\n       </>\n      );\n    } else {\n      return null;\n      // if (error !== null) {\n      //   return (\n      //     <ErrorItem\n      //       error={error}\n      //     />\n      //   );  \n      // } else {\n      //   return (\n      //     <ErrorItem\n      //       error={new Error('Internal Error: Evaluation not available.')}\n      //     />\n      //   );\n      // }\n    }\n  }\n  return (\n    <div className='solver'>\n      <div className = 'solver-left'>\n        <Input\n          value={expression}\n          onChange={onInputChange}\n        />\n        {getDescriptions()}\n      </div>\n      {/* <div className='solver-middle' /> */}\n      <div className = 'solver-right'>\n        {getSteps()}\n      </div>\n      <ErrorMessage error={error} />\n    </div>\n  );\n};\n\nexport default Solver;\n","import React from 'react';\nimport Solver from './Solver';\nimport '../styles/App.css';\n\nconst App = () => {\n  return (\n    <div className='app'>\n      <Solver />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}