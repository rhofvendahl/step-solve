{"version":3,"sources":["components/Input.tsx","constants.ts","solve.ts","components/Step.tsx","components/Description.tsx","components/ErrorMessage.tsx","components/Solver.tsx","components/App.tsx","index.tsx"],"names":["Input","value","onChange","className","type","event","colors","tokenizeLiteral","literal","isNaN","Number","Error","split","length","parseFloat","parseInt","resolveNegatives","tokens","newTokens","i","nextToken","push","newValue","formatFloat","number","digits","formatted","toString","toFixed","performMathOperation","computed","prevComputeNext","start","end","description","operatorIndex","undefined","newToken","leftOperand","rightOperand","operator","Math","pow","n","nString","lastDigit","charAt","truncated","suffix","formatOrdinal","leftTokens","slice","map","token","rightTokens","concat","console","log","join","formatTokens","performOperation","parenStart","parenEnd","contents","contentsOperated","contentsComputed","contentsPrevComputeNext","tokensTemp","computedTemp","prevComputeNextTemp","newTokensResolved","evaluate","text","includes","j","tokenize","isNegative","establishNegatives","prevStep","computeNext","steps","error","Step","initial","step","index","computeNextInterval","indexedTokens","computedColor","computeNextColor","mapTokens","adjustedValue","style","color","fontWeight","preComputeNext","postComputeNext","computeNextInner","border","Description","descriptionColor","ErrorMessage","message","newMessage","toLowerCase","softenMessage","Solver","React","useState","expression","setExpression","setSteps","setError","updateState","evaluateResult","useEffect","target","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.dc27bb3c.chunk.js","sourcesContent":["import React from 'react';\nimport '../styles/Input.css';\n\ntype InputProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n}\n\nconst Input = ({ value, onChange }: InputProps) => {\n  return (\n    <div className='input'>\n      <input\n        type='text'\n        value={value}\n        onChange={(event: React.ChangeEvent<HTMLInputElement>): void => onChange(event)}\n      />\n    </div>\n  );\n};\n\nexport default Input;\n","const colors = [\n  '#CC0B00',\n  '#E69138',\n  '#F1C231',\n  '#6AA850',\n  '#3D85C6',\n  '#674FA7'\n];\n\nexport { colors };","import Description from \"./components/Description\";\n\n// Debugging utility.\nconst formatTokens = (tokens: Token[]): string => {\n  let formatted = tokens.map((token) => token.value.toString()).join(' ')\n  formatted = formatted.split('neg (').join('-(')\n  return formatted\n}\n\nexport type TokenType = 'operator' | 'number' | 'parentheses';\nexport type TokenValue = string | number;\nexport type Token = {\n  type: TokenType,\n  value: TokenValue\n};\n\nexport type Interval = {\n  start: number,\n  end: number\n}\n\nexport type Step = {\n  tokens: Token[],\n  description: string,\n  computed: number | null,\n  computeNext: Interval | null\n}\n\nconst tokenizeLiteral = (literal: string): Token => {\n  if (!isNaN(Number(literal)) && literal !== '') {\n    if (literal.split('.').length === 2) {\n      return {type: 'number', value: parseFloat(literal)};\n    } else {\n      return {type: 'number', value: parseInt(literal)};\n    }\n  } else {\n    throw new Error('User Error: Literal not recognized.');\n  }\n};\n\nconst tokenize = (text: string): Token[] => {\n  let tokens: Token[] = [];\n  for (let i=0; i < text.length; i++) {\n    // Char at i is a number or \".\".\n    if (!isNaN(parseInt(text.charAt(i))) || text.charAt(i) === '.') {\n      let j = i;\n      while (j < text.length && (!isNaN(parseInt(text.charAt(j))) || text.charAt(j) === '.')) {\n        j += 1;\n      }\n      const literal = text.slice(i, j);\n      const token = tokenizeLiteral(literal);\n      tokens.push(token);\n      i = j-1;\n    // Char at i is an operator.\n    } else if ('^*/+-'.includes(text.charAt(i))) {\n      tokens.push({type: 'operator', value: text.charAt(i)});\n    } else if ('()'.includes(text.charAt(i))) {\n      tokens.push({type: 'parentheses', value: text.charAt(i)});      \n    } else if (text.charAt(i) !== ' ') {\n      throw new Error('User Error: \"' + text[i] + '\" is not a valid character.');\n    }\n  }\n  return tokens;\n};\n\n// NOT intended to handle errors.\nconst establishNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i < tokens.length; i++) {\n    // Is a candidate for conversion to \"neg\".\n    if (tokens[i].value === '-') {\n      let isNegative = true;\n      // Minus is at the end.\n      if (i+1 === tokens.length) {\n        isNegative = false;\n      // Minus is followed by an operator or \")\" (i.e. if followed by \"(\" then isNegative would remain \"true\").\n      } else if (tokens[i+1].type === 'operator' || tokens[i+1].value === ')') {\n        isNegative = false;\n      // Minus follows a number.\n      } else if (i > 0 && tokens[i-1].type === 'number') {\n        isNegative = false;\n      }\n      // // Minus is followed by a number followed by an exponent sign (which operates before negative conversion).\n      // } else if (i+2 < tokens.length && tokens[i+2].value === '^') {\n      //   isNegative = false\n      // }\n\n      if (isNegative) {\n        newTokens.push({type: 'operator', value: 'neg'})\n      } else {\n        newTokens.push({type: 'operator', value: '-'})\n      }\n    // Not a candidate for conversion to \"neg\".\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value})\n    }\n  }\n  return newTokens;\n};\n\n// Only handles errors related to bad \"neg\"s.\nconst resolveNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === 'neg') {\n      // Handle bad \"neg\"s.\n      if (i+1 >= tokens.length) {\n        throw new Error('Internal Error: Expression cannot end with a \"neg\" operator.');\n      } else if (tokens[i+1].type !== 'number' && tokens[i+1].value !== '(') {\n        throw new Error('Internal Error: \"neg\"s must be followed by \"(\" or a number.');\n      }\n      const nextToken = tokens[i+1];\n      // If \"neg\" followed by a number that's not followed by \"^\".\n      if (typeof nextToken.value === 'number' && !(i+2 < tokens.length && tokens[i+2].value === '^')) {\n        let newValue = -1 * nextToken.value;\n        // Prevent \"-0\" values.\n        if (newValue === -0) {\n          newValue = 0;\n        }\n        newTokens.push({type: 'number', value: newValue});\n        i += 1;\n      } else {\n        newTokens.push({type: 'operator', value: 'neg'});\n      }\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value});\n    }\n  }\n  return newTokens;\n};\n\nconst formatOrdinal = (n: number): string => {\n  const nString = n.toString();\n  if (n % 1 !== 0) {\n    return nString + 'th';\n  }\n  const lastDigit = parseInt(nString.charAt(nString.length-1));\n  const truncated = n % 100;\n  let suffix = 'th';\n  if (lastDigit === 1 && truncated !== 11) {\n    suffix = 'st';\n  } else if (lastDigit === 2 && truncated !== 12) {\n    suffix = 'nd';\n  } else if (lastDigit === 3 && truncated !== 13) {\n    suffix = 'rd';\n  }\n  return nString + suffix;\n}\n\nconst formatFloat = (number: number, digits: number): string => {\n  let formatted: number | string = number;\n  // Using workaround to assess digits after decimal, as  \"3.1 % 1\" yields \"0.1000000000000000001\" (not what we want).\n  if (formatted % 1 !== 0 && formatted.toString().split('.')[1].length > digits) {\n    formatted = parseFloat(number.toFixed(digits)).toString() + '...';\n  } else {\n    formatted = number.toString();\n  }\n  return formatted;\n}\n\n// Assumes no \"neg\"s or parentheses; handles most other input logic errors.\nconst performMathOperation = (tokens: Token[]): { tokens: Token[], computed: number, prevComputeNext: Interval, description: string } => {\n  if (tokens.length === 1) {\n    if (tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist only of an operator.');\n    } else {\n      return { tokens: [{type: 'number', value: tokens[0].value}], computed: 0, prevComputeNext: { start: 0, end: 1 }, description: 'resolve parentheses' }; \n    }\n  }\n\n  let operatorIndex: number | undefined = undefined;\n  // Exponents are right-associative, so are applied right to left.\n  for (let i=tokens.length-1; i >= 0; i--) {\n    if (tokens[i].value === '^') {\n      operatorIndex = i;\n      break;\n    }\n  }\n  // Search for \"*\"s or \"/\"s, left to right.\n  if (operatorIndex === undefined) {\n    for (let i=0; i < tokens.length; i++) {\n      if (tokens[i].value === '*' || tokens[i].value === '/') {\n        operatorIndex = i;\n        break;\n      }\n    }\n  }\n  // Search for \"+\"s or \"-\"s, left to right.\n  if (operatorIndex === undefined) {\n    for (let i=0; i < tokens.length; i++) {\n      if (tokens[i].value === '+' || tokens[i].value === '-') {\n        operatorIndex = i;\n        break;\n      }\n    }\n  }\n\n  if (operatorIndex === undefined) {\n    throw new Error('User Error: Multiple tokens in expression with no operator.');\n  } else if (operatorIndex === 0) {\n    throw new Error('User Error: Expression cannot start with an operator.');\n } else if (operatorIndex === tokens.length-1) {\n   throw new Error('User Error: Expression cannot end with an operator.');\n  }\n\n  let newToken: Token | undefined = undefined;\n\n  const leftOperand: Token = tokens[operatorIndex-1];\n  const rightOperand: Token = tokens[operatorIndex+1];\n  const operator: Token = tokens[operatorIndex];\n  let description = '';\n  if (typeof leftOperand.value === 'number' && typeof rightOperand.value === 'number') {\n    let newValue: number | undefined = undefined;\n    if (operator.value === '^') {\n      if (leftOperand.value < 0 && rightOperand.value % 1 !== 0) {\n        throw new Error('User Error: ' + leftOperand.value.toString() + '^' + rightOperand.value.toString() + ' results in an imaginary number, which is not supported.')\n      }\n      newValue = Math.pow(leftOperand.value, rightOperand.value);\n      description = 'raise ' + formatFloat(leftOperand.value, 3) + ' to the ' + formatOrdinal(rightOperand.value) + ' power';\n    } else if (operator.value === '*') {\n      newValue = leftOperand.value*rightOperand.value;\n      description = 'multiply ' + formatFloat(leftOperand.value, 3) + ' by ' + formatFloat(rightOperand.value, 3);\n    } else if (operator.value === '/') {\n      newValue = leftOperand.value/rightOperand.value;\n      description = 'divide ' + formatFloat(leftOperand.value, 3) + ' by ' + formatFloat(rightOperand.value, 3);\n    } else if (operator.value === '+') {\n      newValue = leftOperand.value+rightOperand.value;\n      description = 'add ' + formatFloat(rightOperand.value, 3) + ' to ' + formatFloat(leftOperand.value, 3);\n    } else if (operator.value === '-') {\n      newValue = leftOperand.value-rightOperand.value;\n      description = 'subtract ' + formatFloat(rightOperand.value, 3) + ' from ' + formatFloat(leftOperand.value, 3);\n    }\n    if (newValue === undefined) {\n      throw new Error('Internal Error: \"' + operator.value + '\" operator not recognized.');\n    } else {\n      newToken = {type: 'number', value: newValue};\n    }\n  } else {\n    throw new Error('User Error: \"' + operator.value + '\" operator requires numeric operands.');\n  }\n  \n  if (newToken === undefined) {\n    throw new Error('Internal Error: performSimpleOperation function failed.');\n  } else {\n    const leftTokens = tokens.slice(0, operatorIndex-1).map((token) => ({type: token.type, value: token.value}));\n    const rightTokens = tokens.slice(operatorIndex+2).map((token) => ({type: token.type, value: token.value}));\n    const newTokens = leftTokens.concat([newToken]).concat(rightTokens);      \n    console.log('PERFORMMATHOPERATION');\n    console.log('tokens', formatTokens(tokens));\n    console.log('computed', operatorIndex-1);\n    console.log('prevcomputenext', operatorIndex-1, operatorIndex+2);\n    console.log();\n    return {\n      tokens: newTokens,\n      computed: operatorIndex-1,\n      prevComputeNext: { start: operatorIndex-1, end: operatorIndex+2 },\n      description: description\n    }\n  }\n};\n\n// Only handles errors to do with parentheses.\nconst performOperation = (tokens: Token[]): { tokens: Token[], computed: number, description: string, prevComputeNext: Interval } => {\n  let parenStart: number | undefined = undefined;\n  let parenEnd: number | undefined = undefined;\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === '(') {\n      parenStart = i;\n    } else if (tokens[i].value === ')') {\n      parenEnd = i;\n      break;\n    }\n  }\n\n  if ((parenStart === undefined) !== (parenEnd === undefined)) {\n    throw new Error('User Error: Mismatched parentheses.');\n  }\n\n  let newTokens: Token[] | undefined = undefined;\n  let computed: number | undefined = undefined;\n  let description: string | undefined = undefined;\n  let prevComputeNext: Interval | undefined = undefined;\n  // We'll be working within parentheses.\n  if (parenStart !== undefined && parenEnd !== undefined) {\n    const contents: Token[] = tokens.slice(parenStart+1, parenEnd);\n    if (contents.length === 0) {\n      throw new Error('User Error: Parentheses cannot be empty.');\n    }\n    const { tokens: contentsOperated, computed: contentsComputed, prevComputeNext: contentsPrevComputeNext, description: contentsDescription } = performMathOperation(contents);\n    description = contentsDescription;\n    // Contents operated contains single (hopefully) number.\n    if (contentsOperated.length === 1) {\n      // Remove parentheses when concatenating.\n      const leftTokens = tokens.slice(0, parenStart).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd+1).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n      computed = contentsComputed + leftTokens.length;\n      prevComputeNext = { start: contentsPrevComputeNext.start + leftTokens.length, end: contentsPrevComputeNext.end + leftTokens.length+2 };\n    // Contents operated contains multiple numbers (error cases handled within perform math operation).\n    } else {\n      const leftTokens = tokens.slice(0, parenStart+1).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n      computed = contentsComputed + leftTokens.length;\n      prevComputeNext = { start: contentsPrevComputeNext.start + leftTokens.length, end: contentsPrevComputeNext.end + leftTokens.length };\n    }\n  // There are no parentheses remaining.\n  } else {\n    const { tokens: tokensTemp, computed: computedTemp, prevComputeNext: prevComputeNextTemp, description: descriptionTemp } = performMathOperation(tokens);\n    newTokens = tokensTemp;\n    computed = computedTemp;\n    description = descriptionTemp;\n    prevComputeNext = prevComputeNextTemp;\n  }\n  const newTokensResolved = resolveNegatives(newTokens);\n  // NOTE pretty sure we can assume that negatives were only resolved on the left hand side of \"computed\".\n  const nResolvedNegatives = newTokens.length - newTokensResolved.length;\n  const computedResolved = computed - nResolvedNegatives;\n  return {\n    tokens: newTokensResolved,\n    computed: computedResolved,\n    description: description,\n    prevComputeNext: prevComputeNext\n  };\n};\n\nconst evaluate = (text: string): Step[] | Error => {\n  try {\n    let tokens = tokenize(text);\n    tokens = establishNegatives(tokens);\n    tokens = resolveNegatives(tokens);\n    if (tokens.length === 0) {\n      return [];\n    } else if (tokens.length === 1 && tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist of a single operator.');\n    }\n    let prevStep: Step = {\n      tokens: tokens,\n      description: '[Initial description.]',\n      computeNext: null,\n      computed: null,\n    };\n    const steps: Step[] = [];\n    while (prevStep.tokens.length > 1) {\n      const { tokens, computed, prevComputeNext, description } = performOperation(prevStep.tokens);\n      prevStep.computeNext = prevComputeNext;\n      steps.push(prevStep);\n      prevStep = {\n        computeNext: null,\n        tokens: tokens,\n        description: description,\n        computed: computed\n      }\n    }\n    steps.push(prevStep);\n    return steps;\n  } catch (error) {\n    return error;\n  }\n};\n\nexport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performMathOperation,\n  performOperation,\n  // describeOperation,\n  evaluate,\n  formatTokens,\n  formatFloat\n};","import React from 'react';\nimport { colors } from '../constants';\nimport { formatFloat } from '../solve';\nimport type { Token, Step as StepType } from '../solve';\nimport '../styles/Step.css';\n\ntype StepProps = {\n  initial?: boolean,\n  step: StepType,\n  index: number\n}\n\ntype IndexedToken = {\n  token: Token,\n  index: number\n}\n\nconst Step = ({ initial = false, step, index }: StepProps) => {\n  let computeNextInterval = step.computeNext;\n  if (computeNextInterval === null) {\n    computeNextInterval = { start: 0, end: 0}\n  }\n  const indexedTokens = step.tokens.map((token, i) => ({ token: token, index: i }));\n  const computedColor = step.computed !== null ? colors[(index-1) % colors.length] : 'white';\n  const computeNextColor = step.computeNext !== null ? colors[index % colors.length] : 'white';\n\n  // Transform each token into an element, with special rules for \"computed\" tokens.\n  const mapTokens = ({ token, index }: IndexedToken): React.ReactNode => {\n    let adjustedValue = token.value;\n    if (adjustedValue === 'neg') {\n      adjustedValue = '-';\n    }\n    if (typeof adjustedValue === 'number') {\n      // Display more of decimal portion if it's the final result.\n      if (step.tokens.length === 1) {\n        adjustedValue = formatFloat(adjustedValue, 10);\n      } else {\n        adjustedValue = formatFloat(adjustedValue, 3);\n      }\n    }\n    if (index > 0 && step.tokens[index-1].value !== 'neg') {\n      adjustedValue = ' ' + adjustedValue;\n    }\n    if (step.computed !== null && index === step.computed) {\n      return (<span key={index} className='computed' style={{color: computedColor, fontWeight: 'bold'}}>{adjustedValue}</span>);\n    } else {\n      return (<span key={index}>{adjustedValue}</span>);\n    }\n  };\n  // Establish three subsequences of tokens for before, within and after the \"computedFrom\" interval.\n  const preComputeNext = indexedTokens.slice(0, computeNextInterval.start).map(mapTokens);\n  const postComputeNext = indexedTokens.slice(computeNextInterval.end).map(mapTokens);\n  const computeNextInner = indexedTokens.slice(computeNextInterval.start, computeNextInterval.end).map(mapTokens);\n  let computeNext = (<></>)\n  if (computeNextInner.length > 0) {\n    computeNext = (<span className='compute-next' style={{border: '2px solid ' + computeNextColor}}>{computeNextInner}</span>)\n  }\n  return (\n    <div className={initial ? 'step step-initial' : 'step step-next'}>\n    <span className='expression'>\n      {preComputeNext}\n      {computeNext}\n      {postComputeNext}\n    </span>\n    </div>\n  );\n};\n\nexport default Step;\n\n// ISSUES\n  // \"+-1\" appearing instead of \"+ -1\"","import React from 'react';\nimport { colors } from '../constants';\nimport '../styles/Description.css';\n\ntype DescriptionProps = {\n  description: string,\n  index: number\n}\n\nconst Description = ({ description, index }: DescriptionProps) => {\n  const descriptionColor = colors[(index) % colors.length];\n  return (\n    <div className='description' style={{color: descriptionColor}}>\n      {description}\n    </div>\n  );\n};\n\nexport default Description;\n","import React from 'react';\nimport '../styles/ErrorMessage.css';\n\ntype ErrorMessageProps = {\n  error: Error | null,\n}\n\nconst ErrorMessage = ({ error }: ErrorMessageProps) => {\n  const softenMessage = (message: string) => {\n    let newMessage = message;\n    if (newMessage.split('Internal Error').length > 1) {\n      return newMessage;\n    } else {\n      newMessage = newMessage.split('User Error: ').join('');\n      newMessage = newMessage.toLowerCase();\n      if (newMessage.charAt(newMessage.length-1) === '.') {\n        newMessage = newMessage.slice(0, newMessage.length-1);\n      }\n      return newMessage;\n    }\n  }\n  if (error === null) {\n    return null;\n  } else {\n    return (\n      <div className='error'>\n        {softenMessage(error.message)}\n      </div>\n    );\n  }\n};\n\nexport default ErrorMessage;\n","import React from 'react';\nimport Input from './Input';\nimport Step from './Step';\nimport Description from './Description';\nimport ErrorMessage from './ErrorMessage';\nimport { evaluate } from '../solve';\nimport type { Step as StepType } from '../solve';\nimport '../styles/Solver.css';\n\nconst Solver = () => {\n  const [expression, setExpression] = React.useState('');\n  const [steps, setSteps] = React.useState<StepType[] | null>(null)\n  const [error, setError] = React.useState<Error | null>(null);\n\n  const updateState = (text: string) => {\n    setExpression(text);\n    const evaluateResult = evaluate(text);\n    if (evaluateResult instanceof Error) {\n      setSteps(null);\n      setError(evaluateResult);\n    } else {\n      setSteps(evaluateResult);\n      setError(null);\n    };\n  }\n\n  // Call once at start to sync expression, steps, error.\n  React.useEffect(() => {\n    updateState('1-2+-(4/2-1.5)^-3*2');\n  }, [])\n\n  const onInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    const text = event.target.value;\n    updateState(text);\n  };\n\n  const getDescriptions = () => {\n    if (steps !== null && steps.length > 1) {\n      return steps.slice(1).map((step, i) => (\n        <Description\n          key={i}\n          description={step.description}\n          index={i}\n        />\n      ));\n    } else {\n      return null;\n    }\n  }\n\n  const getSteps = () => {\n    if (steps !== null && steps.length === 0) {\n      return null;\n    } else if (steps !== null && steps.length > 0) {\n      return (\n        <>\n          <Step\n            key={0}\n            initial={true}\n            step={steps[0]}\n            index={0}\n            />\n          {steps.slice(1).map((step, i) => (\n            <Step\n              key={i+1}\n              step={step}\n              index={i+1}\n            />\n          ))}\n       </>\n      );\n    } else {\n      return null;\n    }\n  }\n  return (\n    <div className='solver'>\n      <div className = 'solver-left'>\n        <Input\n          value={expression}\n          onChange={onInputChange}\n        />\n        {getDescriptions()}\n      </div>\n      <div className = 'solver-right'>\n        {getSteps()}\n      </div>\n      <ErrorMessage error={error} />\n    </div>\n  );\n};\n\nexport default Solver;\n","import React from 'react';\nimport Solver from './Solver';\nimport '../styles/App.css';\n\nconst App = () => {\n  return (\n    <div className='app'>\n      <Solver />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}