{"version":3,"sources":["components/Item.tsx","components/InputItem.tsx","components/StepItem.tsx","components/DescriptionItem.tsx","solve.ts","components/Solver.tsx","components/App.tsx","index.tsx"],"names":["colors","Item","content","InputItem","value","onChange","className","type","event","StepItem","initial","step","index","computeNextInterval","computeNext","start","end","indexedTokens","tokens","map","token","i","computedColor","computed","length","computeNextColor","console","log","mapTokens","adjustedValue","toString","style","color","fontWeight","preComputeNext","slice","postComputeNext","computeNextInner","border","getContent","DescriptionItem","description","descriptionColor","formatTokens","formatted","join","split","tokenizeLiteral","literal","isNaN","Number","Error","parseFloat","parseInt","resolveNegatives","newTokens","nextToken","push","newValue","performMathOperation","tokenValues","operators","operatorIndex","includes","indexOf","undefined","newToken","leftOperand","rightOperand","operator","Math","pow","leftTokens","rightTokens","concat","performOperation","parenStart","parenEnd","contents","contentsOperated","describeOperation","prevTokens","j","operationOutput","k","operationInput","inputTokens","n","nString","lastDigit","charAt","truncated","suffix","getOrdinalString","operationDescription","evaluate","text","tokenize","isNegative","establishNegatives","prevStep","steps","error","Solver","React","useState","expression","setExpression","setSteps","setError","updateState","evaluateResult","message","forEach","useEffect","target","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.da1fd335.chunk.js","sourcesContent":["import React from 'react';\nimport '../styles/Item.css';\n\ntype ItemProps = {\n  content: React.ReactNode\n}\nconst Item = ({ content }: ItemProps) => {\n  return (\n    <>\n      {content}\n    </>\n  );\n};\n\nconst colors = [\n  '#CC0B00',\n  '#E69138',\n  '#F1C231',\n  '#6AA850',\n  '#3D85C6',\n  '#674FA7'\n];\n\nexport { colors };\nexport default Item;\n","import React from 'react';\nimport Item from './Item';\nimport '../styles/InputItem.css';\n\ntype InputItemProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n}\n\nconst InputItem = ({ value, onChange }: InputItemProps) => {\n  const getContent = (): React.ReactNode => {\n    return (\n      <div className='item input'>\n        <input\n          type='text'\n          value={value}\n          onChange={(event: React.ChangeEvent<HTMLInputElement>): void => onChange(event)}\n        />\n      </div>\n    );\n  };\n  return (\n    <Item content={getContent()} />\n  );\n};\n\nexport default InputItem;\n","import React from 'react';\nimport Item, { colors } from './Item';\n// import { formatTokens } from '../solve';\nimport type { Token, Step } from '../solve';\nimport '../styles/StepItem.css';\n// import { tokenToString } from 'typescript';\n\ntype StepItemProps = {\n  initial?: boolean,\n  step: Step,\n  index: number\n}\n\ntype IndexedToken = {\n  token: Token,\n  index: number\n}\n\nconst StepItem = ({ initial = false, step, index }: StepItemProps) => {\n  let computeNextInterval = step.computeNext || { start: 0, end: 0 };\n  const indexedTokens = step.tokens.map((token, i) => ({ token: token, index: i }));\n  const computedColor = step.computed ? colors[(index-1) % colors.length] : 'white';\n  const computeNextColor = step.computeNext ? colors[index % colors.length] : 'white';\n  console.log(index, computedColor, computeNextColor);\n\n  const mapTokens = ({ token, index }: IndexedToken): React.ReactNode => {\n    const adjustedValue = token.value.toString();\n    if (step.computed !== null && index === step.computed.start) {\n      return (<span key={index} className='computed' style={{color: computedColor, fontWeight: 'bold'}}>{adjustedValue}</span>);\n    } else {\n      return (<span key={index}>{adjustedValue}</span>);\n    }\n  };\n  const getContent = (): React.ReactNode => {\n    const preComputeNext = indexedTokens.slice(0, computeNextInterval.start).map(mapTokens);\n    const postComputeNext = indexedTokens.slice(computeNextInterval.end).map(mapTokens);\n    const computeNextInner = indexedTokens.slice(computeNextInterval.start, computeNextInterval.end).map(mapTokens);\n    let computeNext = (<></>)\n    if (computeNextInner.length > 0) {\n      computeNext = (<span className='compute-next' style={{border: '2px solid ' + computeNextColor}}>{computeNextInner}</span>)\n    }\n    return (\n      <div className={initial ? 'item step step-initial' : 'item step step-next'}>\n      <span className='expression'>\n        {preComputeNext}\n        {computeNext}\n        {postComputeNext}\n      </span>\n      </div>\n    );\n  };\n  return (\n    <Item content={getContent()} />\n  );\n};\n\nexport default StepItem;\n","import React from 'react';\nimport Item, { colors } from './Item';\nimport '../styles/DescriptionItem.css';\n\ntype DescriptionItemProps = {\n  description: string,\n  index: number\n}\n\nconst DescriptionItem = ({ description, index }: DescriptionItemProps) => {\n  const descriptionColor = colors[(index) % colors.length];\n  const getContent = (): React.ReactNode => {\n    return (\n      <div className=\"item description\" style={{color: descriptionColor}}>\n        {description}\n      </div>\n    );\n  };\n  return (\n    <Item content={getContent()} />\n  );\n};\n\nexport default DescriptionItem;\n","const formatTokens = (tokens: Token[]): string => {\n  let formatted = tokens.map((token) => token.value.toString()).join(' ')\n  formatted = formatted.split('neg (').join('-(')\n  return formatted\n}\n\nexport type TokenType = 'operator' | 'number';\nexport type TokenValue = string | number;\nexport type Token = {\n  type: TokenType,\n  value: TokenValue\n};\n\nexport type Interval = {\n  start: number,\n  end: number\n}\n\nexport type Step = {\n  tokens: Token[],\n  description: string,\n  computed: Interval | null,\n  computeNext: Interval | null\n}\n\nconst tokenizeLiteral = (literal: string): Token => {\n  if (!isNaN(Number(literal)) && literal !== '') {\n    if (literal.split('.').length === 2) {\n      return {type: 'number', value: parseFloat(literal)};\n    } else {\n      return {type: 'number', value: parseInt(literal)};\n    }\n  } else {\n    throw new Error('User Error: Literal not recognized.');\n  }\n};\n\nconst tokenize = (text: string): Token[] => {\n  let tokens: Token[] = [];\n  for (let i=0; i < text.length; i++) {\n    // Char at i is a number or \".\".\n    if (!isNaN(parseInt(text.charAt(i))) || text.charAt(i) === '.') {\n      let j = i;\n      while (j < text.length && (!isNaN(parseInt(text.charAt(j))) || text.charAt(j) === '.')) {\n        j += 1;\n      }\n      const literal = text.slice(i, j);\n      const token = tokenizeLiteral(literal);\n      tokens.push(token);\n      i = j-1;\n    // Char at i is an operator.\n    } else if ('()^*/+-'.includes(text.charAt(i))) {\n      const token: Token = {type: 'operator', value: text.charAt(i)}\n      tokens.push(token);\n    } else if (text.charAt(i) !== ' ') {\n      throw new Error('User Error: \"' + text[i] + '\" is not a valid character.');\n    }\n  }\n  return tokens;\n};\n\n// NOT intended to handle errors.\nconst establishNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i < tokens.length; i++) {\n    // Is a candidate for conversion to \"neg\".\n    if (tokens[i].value === '-') {\n      let isNegative = true;\n      // Minus is at the end.\n      if (i+1 === tokens.length) {\n        isNegative = false;\n      // Minus is followed by an operator other than \"(\".\n      } else if (tokens[i+1].type === 'operator' && tokens[i+1].value !== '(') {\n        isNegative = false;\n      // Minus follows a number.\n      } else if (i > 0 && tokens[i-1].type === 'number') {\n        isNegative = false;\n      // Minus is followed by a number followed by an exponent sign (which operates before negative conversion).\n      } else if (i+2 < tokens.length && tokens[i+2].value === '^') {\n        isNegative = false\n      }\n\n      if (isNegative) {\n        newTokens.push({type: 'operator', value: 'neg'})\n      } else {\n        newTokens.push({type: 'operator', value: '-'})\n      }\n    // Not a candidate for conversion to \"neg\".\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value})\n    }\n  }\n  return newTokens;\n};\n\n// Only handles errors related to bad \"neg\"s.\nconst resolveNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === 'neg') {\n      // Is at the end of expression (internal because it shouldn't have been converted if at end).\n      if (i+1 >= tokens.length) {\n        throw new Error('Internal Error: Expression cannot end with a \"neg\" operator.');\n      } else {\n        const nextToken = tokens[i+1];\n        // Is followed by \"(\".\n        if (nextToken.value === '(') {\n          newTokens.push({type: 'operator', value: 'neg'});\n        // Is followed by a number.\n        } else if (typeof nextToken.value == 'number') {\n          let newValue = -1 * nextToken.value;\n          // DO NOT resolve \"neg 0\" to \"-0\".\n          if (nextToken.value === 0) {\n            newValue = 0;\n          }\n          newTokens.push({type: 'number', value: newValue});\n          i += 1;\n        // Is followed by something other than \"(\" or a number (internal because shouldn't have been converted if so).\n        } else {\n          throw new Error('Internal Error: \"neg\"s must be followed by \"(\" or a number.');\n        }\n      }\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value});\n    }\n  }\n  return newTokens;\n};\n\n// Assumes no \"neg\"s or parentheses; handles most other input logic errors.\nconst performMathOperation = (tokens: Token[]): Token[] => {\n  if (tokens.length === 1) {\n    if (tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist only of an operator.');\n    } else {\n      return [{type: 'number', value: tokens[0].value}]; \n    }\n  }\n\n  const tokenValues: TokenValue[] = tokens.map((token) => token.value);\n  const operators = ['^', '*', '/', '+', '-'];\n  let operatorIndex: number | undefined = -1;\n  for (let i=0; i<operators.length; i++) {\n    if (tokenValues.includes(operators[i])) {\n      operatorIndex = tokenValues.indexOf(operators[i]);\n      break;\n    };\n  };\n\n  if (operatorIndex === undefined) {\n    throw new Error('User Error: Multiple tokens in expression with no operator.');\n  } else if (operatorIndex === 0) {\n    throw new Error('User Error: Expression cannot start with an operator.');\n } else if (operatorIndex === tokens.length-1) {\n   throw new Error('User Error: Expression cannot end with an operator.');\n  }\n\n  let newToken: Token | undefined = undefined;\n\n  const leftOperand: Token = tokens[operatorIndex-1];\n  const rightOperand: Token = tokens[operatorIndex+1];\n  const operator: Token = tokens[operatorIndex];\n  if (typeof leftOperand.value === 'number' && typeof rightOperand.value === 'number') {\n    let newValue: number | undefined = undefined;\n    if (operator.value === '^') {\n      newValue = Math.pow(leftOperand.value, rightOperand.value);\n    } else if (operator.value === '*') {\n      newValue = leftOperand.value*rightOperand.value;\n    } else if (operator.value === '/') {\n      newValue = leftOperand.value/rightOperand.value;\n    } else if (operator.value === '+') {\n      newValue = leftOperand.value+rightOperand.value;\n    } else if (operator.value === '-') {\n      newValue = leftOperand.value-rightOperand.value;\n    }\n    if (newValue === undefined) {\n      throw new Error('Internal Error: \"' + operator.value + '\" operator not recognized.');\n    } else {\n      newToken = {type: 'number', value: newValue};\n    }\n  } else {\n    throw new Error('User Error: \"' + operator.value + '\" operator requires numeric operands.');\n  }\n  \n  if (newToken === undefined) {\n    throw new Error('Internal error: performSimpleOperation function failed.');\n  } else {\n    const leftTokens = tokens.slice(0, operatorIndex-1).map((token) => ({type: token.type, value: token.value}));\n    const rightTokens = tokens.slice(operatorIndex+2).map((token) => ({type: token.type, value: token.value}));\n    const newTokens = leftTokens.concat([newToken]).concat(rightTokens);      \n    return newTokens;\n  }\n};\n\n// Only handles errors to do with parentheses\n// I'm thinking THIS should return a step...\nconst performOperation = (tokens: Token[]): Token[] => {\n  let parenStart: number | undefined = undefined;\n  let parenEnd: number | undefined = undefined;\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === '(') {\n      parenStart = i;\n    } else if (tokens[i].value === ')') {\n      parenEnd = i;\n      break;\n    }\n  }\n\n  if ((parenStart === undefined) !== (parenEnd === undefined)) {\n    throw new Error('User Error: Mismatched parentheses.');\n  }\n\n  let newTokens: Token[] | undefined = undefined;\n\n  // We'll be working within parentheses.\n  if (parenStart !== undefined && parenEnd !== undefined) {\n    const contents: Token[] = tokens.slice(parenStart+1, parenEnd);\n    if (contents.length === 0) {\n      throw new Error('User Error: Parentheses cannot be empty.');\n    }\n    const contentsOperated = performMathOperation(contents);\n    // Contents operated contains single number.\n    if (contentsOperated.length === 1 && contentsOperated[0].type === 'number') {\n      // Remove parentheses when concatenating.\n      const leftTokens = tokens.slice(0, parenStart).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd+1).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    // Contents operated contains multiple numbers (error cases handled within perform math operation).\n    } else {\n      const leftTokens = tokens.slice(0, parenStart+1).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    }\n  // There are no parentheses remaining.\n  } else {\n    newTokens = performMathOperation(tokens);\n  }\n\n  if (newTokens !== undefined) {\n    newTokens = resolveNegatives(newTokens);\n    return newTokens;\n  } else {\n    throw new Error('Internal Error: \"performOperation\" function failed.');\n  }\n};\n\nconst getOrdinalString = (n: number): string => {\n  const nString = n.toString();\n  if (n % 1 !== 0) {\n    return nString + 'th';\n  }\n  const lastDigit = parseInt(nString.charAt(nString.length-1));\n  const truncated = n % 100;\n  let suffix = 'th';\n  if (lastDigit === 1 && truncated !== 11) {\n    suffix = 'st';\n  } else if (lastDigit === 2 && truncated !== 12) {\n    suffix = 'nd';\n  } else if (lastDigit === 3 && truncated !== 13) {\n    suffix = 'rd';\n  }\n  return nString + suffix;\n}\n\n// Awkward, but easier & simpler than tracking and passing changes through all of the index-changing operations (math operations, resolving parentheses, resolving negatives).\n// Assumes both sequences describe valid equations.\nconst describeOperation = (prevTokens: Token[], newTokens: Token[]): { operationInput: Interval, operationOutput: Interval, operationDescription: string } => {\n  let i = prevTokens.length-1;\n  let j = newTokens.length-1;\n  // Move along both sets of tokens, iterating backward to ensure that i hits the first operator in cases like \"1*1*1\" to \"1*1\".\n  while (i >= 0 && j >= 0 && prevTokens[i].value === newTokens[j].value) {\n    i -= 1;\n    j -= 1;\n  }\n\n  // Case where input and output share ending numbers (eg. \"1*1+1\" to \"1+1\"), so i continues on to the operator that was resolved.\n    // I believe all remaining cases leave i and j at the end of the input & output sequences.\n    // Including \"(1)\", where there is no operator; and \"1*1*1\" to \"1*1\", where j hits the end of the array.\n  if (prevTokens[i].type === 'operator' && prevTokens[i].value !== ')') {\n    i += 1;\n    j += 1;\n  }\n  const operationOutput: Interval = {\n    start: j,\n    end: j+1\n  };\n  let k = i;\n  // Cases with inputs like \"(1)\", \"(1+1)\", \"neg(1)\", \"neg(1+1)\".\n  if (prevTokens[i].value === ')') {\n    while (k >= 0 && prevTokens[k].value !== '(') {\n      k -= 1;\n    }\n    if (k > 0 && prevTokens[k-1].value === 'neg') {\n      k -= 1;\n    }\n  // Cases with inputs like \"1+1\".\n  } else {\n    k -= 2;\n  }\n  const operationInput: Interval = {\n    start: k,\n    end: i+1\n  }\n  const inputTokens = prevTokens.slice(k, i+1);\n\n  let operatorIndex = 0;\n  for ( ; operatorIndex < inputTokens.length; operatorIndex++) {\n    const token = inputTokens[operatorIndex];\n    if (token.type === 'operator' && typeof token.value === 'string' && !['neg', '(', ')'].includes(token.value)) {\n      break;\n    }\n  }\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n  }\n\n  let description: string | undefined = undefined;\n  console.log('DESCRIBE OPERATION')\n  console.log('input tokens', formatTokens(inputTokens));\n  console.log('operator index', operatorIndex);\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n    throw new Error('Internal Error: \"describeOperation\" function recieved a misplaced operator.');\n  // No operator in expression (eg. \"(1)\" to \"1\").\n  } else if (operatorIndex === inputTokens.length) {\n    description = 'resolve parentheses';\n  } else if (operatorIndex < inputTokens.length) {\n    const leftOperand = inputTokens[operatorIndex-1].value;\n    const rightOperand = inputTokens[operatorIndex+1].value;\n    if (typeof leftOperand !== 'number' || typeof rightOperand !== 'number') {\n      throw new Error('Internal Error: \"describeOperation\" function received invalid operands.');\n    }\n    if (inputTokens[operatorIndex].value === '^') {\n      description = 'raise ' + inputTokens[operatorIndex-1].value.toString() + ' to the ' + getOrdinalString(rightOperand) + ' power';\n    } else if (inputTokens[operatorIndex].value === '*') {\n      description = 'multiply ' + inputTokens[operatorIndex-1].value.toString() + ' by ' + inputTokens[operatorIndex+1].value.toString();\n    } else if (inputTokens[operatorIndex].value === '/') {\n      description = 'divide ' + inputTokens[operatorIndex-1].value.toString() + ' by ' + inputTokens[operatorIndex+1].value.toString();\n    } else if (inputTokens[operatorIndex].value === '+') {\n      description = 'add ' + inputTokens[operatorIndex+1].value.toString() + ' to ' + inputTokens[operatorIndex-1].value.toString()\n    } else if (inputTokens[operatorIndex].value === '-') {\n      description = 'subtract ' + inputTokens[operatorIndex+1].value.toString() + ' from ' + inputTokens[operatorIndex-1].value.toString();\n    }  \n  } else {\n\n  }\n  if (description === undefined) {\n    throw new Error('Internal Error: function \"describeOperation\" failed.');\n  }\n  return {\n    operationInput: operationInput,\n    operationOutput: operationOutput,\n    operationDescription: description\n  };\n};\n\nconst evaluate = (text: string): Step[] | Error => {\n  try {\n    let tokens = tokenize(text);\n    tokens = establishNegatives(tokens);\n    tokens = resolveNegatives(tokens);\n    if (tokens.length === 0) {\n      return [];\n    } else if (tokens.length === 1 && tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist of a single operator.');\n    }\n    let prevStep: Step = {\n      tokens: tokens,\n      description: '[Initial description.]',\n      computeNext: null,\n      computed: null,\n    };\n    const steps: Step[] = [];\n    while (prevStep.tokens.length > 1) {\n      const tokens = performOperation(prevStep.tokens);\n      const { operationInput, operationOutput, operationDescription } = describeOperation(prevStep.tokens, tokens);\n      prevStep.computeNext = operationInput;\n      steps.push(prevStep);\n      prevStep = {\n        computeNext: null,\n        tokens: tokens,\n        description: operationDescription,\n        computed: operationOutput\n      }\n    }\n    steps.push(prevStep);\n    return steps;\n  } catch (error) {\n    return error;\n  }\n};\n\nexport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performMathOperation,\n  performOperation,\n  describeOperation,\n  evaluate,\n  formatTokens\n};\n\n// NOTE\n  // Preference is to trust token.type, with typeof used when necessary for type narrowing.\n\n// TODO\n  // Returns and conditionals and exceptions all over the place are leaving things a mess (especially performMathOperation).\n    // In theory having early returns makes it so there are guarantees down the line, but that gets messy fast.....\n  // Ya, checks and exceptions are all over the place. resolve that.\n  // Consider un-refactoring the '\"number\"' back to '\"float\" | \"integer\"', since apparently JS/TS is terrible at discerning floats/ints from numbers\n  // Consider adding \"patentheses\" type, to simplify checking for \"operation but not parentheses\".","import React from 'react';\nimport InputItem from './InputItem';\nimport StepItem from './StepItem';\nimport DescriptionItem from './DescriptionItem';\nimport {\n  evaluate,\n  formatTokens\n} from '../solve';\nimport type {\n  // Token,\n  Step\n} from '../solve';\nimport '../styles/Solver.css';\n\nconst Solver = () => {\n  const [expression, setExpression] = React.useState('');\n  const [steps, setSteps] = React.useState<Step[] | null>(null)\n  const [error, setError] = React.useState<Error | null>(null);\n\n  const updateState = (text: string) => {\n    setExpression(text);\n    const evaluateResult = evaluate(text);\n    if (evaluateResult instanceof Error) {\n      console.log(evaluateResult.message);\n      setSteps(null);\n      setError(evaluateResult);\n    } else {\n      evaluateResult.forEach((step) => {\n        console.log(formatTokens(step.tokens));\n      });\n      setSteps(evaluateResult);\n      setError(null);\n    };\n  }\n\n  React.useEffect(() => {\n    updateState('');\n  }, [])\n\n  const onInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    const text = event.target.value;\n    updateState(text);\n  };\n\n  const getDescriptions = () => {\n    if (steps !== null && steps.length > 1) {\n      return steps.slice(1).map((step, i) => (\n        <DescriptionItem\n          key={i}\n          description={step.description}\n          index={i}\n        />\n      ));\n    } else {\n      return null;\n    }\n  }\n\n  const getSteps = () => {\n    if (steps !== null && steps.length === 0) {\n      return null;\n    } else if (steps !== null && steps.length > 0) {\n      return (\n        <>\n          <StepItem\n            key={0}\n            initial={true}\n            step={steps[0]}\n            index={0}\n            />\n          {steps.slice(1).map((step, i) => (\n            <StepItem\n              key={i+1}\n              step={step}\n              index={i+1}\n            />\n          ))}\n       </>\n      );\n    } else {\n      return null;\n      // if (error !== null) {\n      //   return (\n      //     <ErrorItem\n      //       error={error}\n      //     />\n      //   );  \n      // } else {\n      //   return (\n      //     <ErrorItem\n      //       error={new Error('Internal Error: Evaluation not available.')}\n      //     />\n      //   );\n      // }\n    }\n  }\n  const getError = () => {\n    if (error === null) {\n      return null;\n    } else {\n      return (\n        <div className='error'>{error.message}</div>\n      )\n    }\n  };\n  return (\n    <div className='solver'>\n      <div className = 'solver-left'>\n        <InputItem\n          value={expression}\n          onChange={onInputChange}\n        />\n        {getDescriptions()}\n      </div>\n      {/* <div className='solver-middle' /> */}\n      <div className = 'solver-right'>\n        {getSteps()}\n      </div>\n      {getError()}\n    </div>\n  );\n};\n\nexport default Solver;\n","import React from 'react';\nimport Solver from './Solver';\nimport '../styles/App.css';\n\nconst App = () => {\n  return (\n    <div className='app'>\n      <Solver />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}