{"version":3,"sources":["components/Item.tsx","components/InputItem.tsx","solve.ts","components/StepItem.tsx","components/DescriptionItem.tsx","components/ErrorItem.tsx","components/Solver.tsx","components/App.tsx","index.tsx"],"names":["Item","content","InputItem","value","onChange","className","type","event","formatTokens","tokens","formatted","map","token","toString","join","split","tokenizeLiteral","literal","isNaN","Number","Error","length","parseFloat","parseInt","resolveNegatives","newTokens","i","nextToken","push","newValue","performMathOperation","tokenValues","operators","operatorIndex","includes","indexOf","undefined","newToken","leftOperand","rightOperand","operator","Math","pow","leftTokens","slice","rightTokens","concat","performOperation","parenStart","parenEnd","contents","contentsOperated","evaluate","text","charAt","j","tokenize","isNegative","establishNegatives","steps","error","Step","initial","step","DescriptionItem","description","ErrorItem","message","getContent","Solver","React","useState","expression","setExpression","setSteps","setError","target","evaluateResult","console","log","forEach","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5ab6b5c4.chunk.js","sourcesContent":["import React from 'react';\nimport '../styles/Item.css';\n\ntype ItemProps = {\n  content: React.ReactNode\n}\nconst Item = ({ content }: ItemProps) => {\n  return (\n    <>\n      {content}\n    </>\n  );\n};\n\nexport default Item;\n","import React from 'react';\nimport Item from './Item';\nimport '../styles/InputItem.css';\n\ntype InputItemProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n}\n\nconst InputItem = ({ value, onChange }: InputItemProps) => {\n  const getContent = () => {\n    return (\n      <div className='item-input'>\n        <input\n          type='text'\n          value={value}\n          onChange={(event: React.ChangeEvent<HTMLInputElement>): void => onChange(event)}\n        />\n      </div>\n    );\n  };\n  return (\n    <Item content={getContent()} />\n  );\n};\n\nexport default InputItem;\n","const formatTokens = (tokens: Token[]): string => {\n  let formatted = tokens.map((token) => token.value.toString()).join(' ')\n  formatted = formatted.split('neg (').join('-(')\n  return formatted\n}\n\nexport type TokenType = 'operator' | 'number';\nexport type TokenValue = string | number;\nexport type Token = {\n  type: TokenType,\n  value: TokenValue\n};\n\nconst tokenizeLiteral = (literal: string): Token => {\n  if (!isNaN(Number(literal)) && literal !== '') {\n    if (literal.split('.').length === 2) {\n      return {type: 'number', value: parseFloat(literal)};\n    } else {\n      return {type: 'number', value: parseInt(literal)};\n    }\n  } else {\n    throw new Error('User Error: Literal not recognized.');\n  }\n};\n\nconst tokenize = (text: string): Token[] => {\n  let tokens: Token[] = [];\n  for (let i=0; i < text.length; i++) {\n    // Char at i is a number or \".\".\n    if (!isNaN(parseInt(text.charAt(i))) || text.charAt(i) === '.') {\n      let j = i;\n      while (j < text.length && (!isNaN(parseInt(text.charAt(j))) || text.charAt(j) === '.')) {\n        j += 1;\n      }\n      const literal = text.slice(i, j);\n      const token = tokenizeLiteral(literal);\n      tokens.push(token);\n      i = j-1;\n    // Char at i is an operator.\n    } else if ('()^*/+-'.includes(text.charAt(i))) {\n      const token: Token = {type: 'operator', value: text.charAt(i)}\n      tokens.push(token);\n    } else if (text.charAt(i) !== ' ') {\n      throw new Error('User Error: \"' + text[i] + '\" is not a valid character.');\n    }\n  }\n  return tokens;\n};\n\n// NOT intended to handle errors.\nconst establishNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i < tokens.length; i++) {\n    // Is a candidate for conversion to \"neg\".\n    if (tokens[i].value === '-') {\n      let isNegative = true;\n      // Minus is at the end.\n      if (i+1 === tokens.length) {\n        isNegative = false;\n      // Minus is followed by an operator other than \"(\".\n      } else if (tokens[i+1].type === 'operator' && tokens[i+1].value !== '(') {\n        isNegative = false;\n      // Minus follows a number.\n      } else if (i > 0 && tokens[i-1].type === 'number') {\n        isNegative = false;\n      // Minus is followed by a number followed by an exponent sign (which operates before negative conversion).\n      } else if (i+2 < tokens.length && tokens[i+2].value === '^') {\n        isNegative = false\n      }\n\n      if (isNegative) {\n        newTokens.push({type: 'operator', value: 'neg'})\n      } else {\n        newTokens.push({type: 'operator', value: '-'})\n      }\n    // Not a candidate for conversion to \"neg\".\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value})\n    }\n  }\n  return newTokens;\n};\n\n// Only handles errors related to bad \"neg\"s.\nconst resolveNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === 'neg') {\n      // Is at the end of expression (internal because it shouldn't have been converted if at end).\n      if (i+1 >= tokens.length) {\n        throw new Error('Internal Error: Expression cannot end with a \"neg\" operator.');\n      } else {\n        const nextToken = tokens[i+1];\n        // Is followed by \"(\".\n        if (nextToken.value === '(') {\n          newTokens.push({type: 'operator', value: 'neg'});\n        // Is followed by a number.\n        } else if (typeof nextToken.value == 'number') {\n          let newValue = -1 * nextToken.value;\n          // DO NOT resolve \"neg 0\" to \"-0\".\n          if (nextToken.value === 0) {\n            newValue = 0;\n          }\n          newTokens.push({type: 'number', value: newValue});\n          i += 1;\n        // Is followed by something other than \"(\" or a number (internal because shouldn't have been converted if so).\n        } else {\n          throw new Error('Internal Error: \"neg\"s must be followed by \"(\" or a number.');\n        }\n      }\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value});\n    }\n  }\n  return newTokens;\n};\n\n// Assumes no \"neg\"s or parentheses; handles most other input logic errors.\nconst performMathOperation = (tokens: Token[]): Token[] => {\n  if (tokens.length === 1) {\n    if (tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist only of an operator.');\n    } else {\n      return [{type: 'number', value: tokens[0].value}]; \n    }\n  }\n\n  const tokenValues: TokenValue[] = tokens.map((token) => token.value);\n  const operators = ['^', '*', '/', '+', '-'];\n  let operatorIndex: number | undefined = -1;\n  for (let i=0; i<operators.length; i++) {\n    if (tokenValues.includes(operators[i])) {\n      operatorIndex = tokenValues.indexOf(operators[i]);\n      break;\n    };\n  };\n\n  if (operatorIndex === undefined) {\n    throw new Error('User Error: Multiple tokens in expression with no operator.');\n  } else if (operatorIndex === 0) {\n    throw new Error('User Error: Expression cannot start with an operator.');\n } else if (operatorIndex === tokens.length-1) {\n   throw new Error('User Error: Expression cannot end with an operator.');\n  }\n\n  let newToken: Token | undefined = undefined;\n\n  const leftOperand: Token = tokens[operatorIndex-1];\n  const rightOperand: Token = tokens[operatorIndex+1];\n  const operator: Token = tokens[operatorIndex];\n  if (typeof leftOperand.value === 'number' && typeof rightOperand.value === 'number') {\n    let newValue: number | undefined = undefined;\n    if (operator.value === '^') {\n      newValue = Math.pow(leftOperand.value, rightOperand.value);\n    } else if (operator.value === '*') {\n      newValue = leftOperand.value*rightOperand.value;\n    } else if (operator.value === '/') {\n      newValue = leftOperand.value/rightOperand.value;\n    } else if (operator.value === '+') {\n      newValue = leftOperand.value+rightOperand.value;\n    } else if (operator.value === '-') {\n      newValue = leftOperand.value-rightOperand.value;\n    }\n    if (newValue === undefined) {\n      throw new Error('Internal Error: \"' + operator.value + '\" operator not recognized.');\n    } else {\n      newToken = {type: 'number', value: newValue};\n    }\n  } else {\n    throw new Error('User Error: \"' + operator.value + '\" operator requires numeric operands.');\n  }\n  \n  if (newToken === undefined) {\n    throw new Error('Internal error: performSimpleOperation function failed.');\n  } else {\n    const leftTokens = tokens.slice(0, operatorIndex-1).map((token) => ({type: token.type, value: token.value}));\n    const rightTokens = tokens.slice(operatorIndex+2).map((token) => ({type: token.type, value: token.value}));\n    const newTokens = leftTokens.concat([newToken]).concat(rightTokens);      \n    return newTokens;\n  }\n};\n\n// Only handles errors to do with parentheses\nconst performOperation = (tokens: Token[]): Token[] => {\n  let parenStart: number | undefined = undefined;\n  let parenEnd: number | undefined = undefined;\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === '(') {\n      parenStart = i;\n    } else if (tokens[i].value === ')') {\n      parenEnd = i;\n      break;\n    }\n  }\n\n  if ((parenStart === undefined) !== (parenEnd === undefined)) {\n    throw new Error('User Error: Mismatched parentheses.');\n  }\n\n  let newTokens: Token[] | undefined = undefined;\n\n  // We'll be working within parentheses.\n  if (parenStart !== undefined && parenEnd !== undefined) {\n    const contents: Token[] = tokens.slice(parenStart+1, parenEnd);\n    if (contents.length === 0) {\n      throw new Error('User Error: Parentheses cannot be empty.');\n    }\n    const contentsOperated = performMathOperation(contents);\n    // Contents operated contains single number.\n    if (contentsOperated.length === 1 && contentsOperated[0].type === 'number') {\n      // Remove parentheses when concatenating.\n      const leftTokens = tokens.slice(0, parenStart).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd+1).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    // Contents operated contains multiple numbers (error cases handled within perform math operation).\n    } else {\n      const leftTokens = tokens.slice(0, parenStart+1).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    }\n  // There are no parentheses remaining.\n  } else {\n    newTokens = performMathOperation(tokens);\n  }\n\n  if (newTokens !== undefined) {\n    newTokens = resolveNegatives(newTokens);\n    return newTokens;\n  } else {\n    throw new Error('Internal Error: \"performOperation\" function failed.');\n  }\n};\n\nconst evaluate = (text: string): Token[][] | Error => {\n  try {\n    let tokens = tokenize(text);\n    tokens = establishNegatives(tokens);\n    tokens = resolveNegatives(tokens);\n    if (tokens.length === 0) {\n      return [];\n    } else if (tokens.length === 1 && tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist of a single operator.');\n    }\n    let steps = [tokens];\n    while (steps[steps.length-1].length > 1) {\n      tokens = steps[steps.length-1];\n      tokens = performOperation(tokens);\n      steps.push(tokens);\n    }\n    return steps;\n  } catch (error) {\n    return error;\n  }\n};\n\nexport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performMathOperation,\n  performOperation,\n  evaluate,\n  formatTokens\n};\n\n// NOTE\n  // Preference is to trust token.type, with typeof used when necessary for type narrowing.\n\n// TODO\n  // Returns and conditionals and exceptions all over the place are leaving things a mess (especially performMathOperation).\n    // In theory having early returns makes it so there are guarantees down the line, but that gets messy fast.....\n  // Ya, checks and exceptions are all over the place. resolve that.\n  // Consider un-refactoring the '\"number\"' back to '\"float\" | \"integer\"', since apparently JS/TS is terrible at discerning floats/ints from numbers","import React from 'react';\nimport Item from './Item';\nimport { formatTokens } from '../solve';\nimport type { Token } from '../solve';\nimport '../styles/StepItem.css';\n\ntype StepProps = {\n  initial?: boolean,\n  step: Token[]\n}\nconst Step = ({ initial=false, step }: StepProps) => {\n  const getContent = () => {\n    return (\n      <div className={initial ? 'item item-step item-step-initial' : 'item item-step item-step-next'}>\n        {formatTokens(step)}\n      </div>\n    );\n  };\n  return (\n    <Item content={getContent()} />\n  );\n};\n\nexport default Step;\n","import React from 'react';\nimport Item from './Item';\nimport '../styles/DescriptionItem.css';\n\ntype DescriptionItemProps = {\n  description: string\n}\n\nconst DescriptionItem = ({ description }: DescriptionItemProps) => {\n  const getContent = () => {\n    return (\n      <div className=\"item item-description\">\n        {description}\n      </div>\n    );\n  };\n  return (\n    <Item content={getContent()} />\n  );\n};\n\nexport default DescriptionItem;\n","import React from 'react';\nimport Item from './Item';\nimport { formatTokens } from '../solve';\nimport type { Token } from '../solve';\nimport '../styles/ErrorItem.css';\n\ntype ErrorItemProps = {\n  error: Error | null\n}\nconst ErrorItem = ({ error }: ErrorItemProps) => {\n  const getContent = () => {\n    let message = '';\n    if (error !== null) {\n      message = error.message;\n    }\n    return (\n      <div className=\"item item-error\">\n        {message}\n      </div>\n    );\n  };\n  return (\n    <Item content={getContent()} />\n  );\n};\n\nexport default ErrorItem;\n","import React from 'react';\nimport InputItem from './InputItem';\nimport StepItem from './StepItem';\nimport DescriptionItem from './DescriptionItem';\nimport ErrorItem from './ErrorItem';\nimport {\n  // tokenizeLiteral,\n  // tokenize,\n  // establishNegatives,\n  // resolveNegatives,\n  // performMathOperation,\n  // performOperation,\n  evaluate,\n  formatTokens\n} from '../solve';\nimport type { Token } from '../solve';\nimport '../styles/Solver.css';\n\nconst Solver = () => {\n  const [expression, setExpression] = React.useState(\"\");\n  const [steps, setSteps] = React.useState<Token[][] | null>(null)\n  const [error, setError] = React.useState<Error | null>(null);\n\n  const onInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    const text = event.target.value;\n    setExpression(text);\n    const evaluateResult = evaluate(text);\n    if (evaluateResult instanceof Error) {\n      console.log(evaluateResult.message);\n      setSteps(null);\n      setError(evaluateResult);\n    } else {\n      evaluateResult.forEach((evaluateResult) => {\n        console.log(formatTokens(evaluateResult));\n      });\n      setSteps(evaluateResult);\n      setError(null);\n    };\n  };\n\n  const getDescriptions = () => {\n    if (steps !== null && steps.length > 1) {\n      return steps.slice(1).map((step, i) => (\n        <DescriptionItem\n          key={i}\n          description={'[Description text.]'}\n        />\n      ));\n    } else {\n      return null;\n    }\n  }\n\n  const getSteps = () => {\n    if (steps !== null && steps.length === 0) {\n      return null;\n    } else if (steps !== null && steps.length > 0) {\n      return (\n        <>\n          <StepItem\n            initial={true}\n            step={steps[0]}\n          />\n          {steps.slice(1).map((step, i) => (\n            <StepItem\n              key={i}\n              step={step}\n            />\n          ))}\n       </>\n      );\n    } else {\n      if (error !== null) {\n        return (\n          <ErrorItem\n            error={error}\n          />\n        );  \n      } else {\n        return (\n          <ErrorItem\n            error={new Error('Internal Error: Evaluation not available.')}\n          />\n        );\n      }\n    }\n  }\n  return (\n    <div className='solver'>\n      <div className = 'solver-left'>\n        <InputItem\n          value={expression}\n          onChange={onInputChange}\n        />\n        {getDescriptions()}\n      </div>\n      <div className='solver-middle' />\n      <div className = 'solver-right'>\n        {getSteps()}\n      </div>\n    </div>\n  );\n};\n\nexport default Solver;\n","import React from 'react';\nimport Solver from './Solver';\nimport '../styles/App.css';\n\nconst App = () => {\n  return (\n    <div className='app'>\n      <Solver />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}