{"version":3,"sources":["components/Input.tsx","constants.ts","solve.ts","components/Step.tsx","components/Description.tsx","components/ErrorMessage.tsx","components/Solver.tsx","components/App.tsx","index.tsx"],"names":["Input","value","onChange","className","type","event","colors","formatTokens","tokens","formatted","map","token","toString","join","split","tokenizeLiteral","literal","isNaN","Number","Error","length","parseFloat","parseInt","resolveNegatives","newTokens","i","nextToken","push","newValue","performMathOperation","tokenValues","operators","operatorIndex","includes","indexOf","undefined","newToken","leftOperand","rightOperand","operator","Math","pow","leftTokens","slice","rightTokens","concat","performOperation","parenStart","parenEnd","contents","contentsOperated","formatFloat","number","digits","toFixed","describeOperation","prevTokens","j","operationOutput","start","end","k","operationInput","inputTokens","description","console","log","n","nString","lastDigit","charAt","truncated","suffix","formatOrdinal","operationDescription","evaluate","text","tokenize","isNegative","establishNegatives","prevStep","computeNext","computed","steps","error","Step","initial","step","index","computeNextInterval","indexedTokens","computedColor","computeNextColor","mapTokens","adjustedValue","style","color","fontWeight","preComputeNext","postComputeNext","computeNextInner","border","Description","descriptionColor","ErrorMessage","message","newMessage","toLowerCase","softenMessage","Solver","React","useState","expression","setExpression","setSteps","setError","updateState","evaluateResult","forEach","useEffect","target","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.e7e11539.chunk.js","sourcesContent":["import React from 'react';\nimport '../styles/Input.css';\n\ntype InputProps = {\n  value: string,\n  onChange: (event: React.ChangeEvent<HTMLInputElement>) => void\n}\n\nconst Input = ({ value, onChange }: InputProps) => {\n  return (\n    <div className='input'>\n      <input\n        type='text'\n        value={value}\n        onChange={(event: React.ChangeEvent<HTMLInputElement>): void => onChange(event)}\n      />\n    </div>\n  );\n};\n\nexport default Input;\n","const colors = [\n  '#CC0B00',\n  '#E69138',\n  '#F1C231',\n  '#6AA850',\n  '#3D85C6',\n  '#674FA7'\n];\n\nexport { colors };","const formatTokens = (tokens: Token[]): string => {\n  let formatted = tokens.map((token) => token.value.toString()).join(' ')\n  formatted = formatted.split('neg (').join('-(')\n  return formatted\n}\n\nexport type TokenType = 'operator' | 'number';\nexport type TokenValue = string | number;\nexport type Token = {\n  type: TokenType,\n  value: TokenValue\n};\n\nexport type Interval = {\n  start: number,\n  end: number\n}\n\nexport type Step = {\n  tokens: Token[],\n  description: string,\n  computed: Interval | null,\n  computeNext: Interval | null\n}\n\nconst tokenizeLiteral = (literal: string): Token => {\n  if (!isNaN(Number(literal)) && literal !== '') {\n    if (literal.split('.').length === 2) {\n      return {type: 'number', value: parseFloat(literal)};\n    } else {\n      return {type: 'number', value: parseInt(literal)};\n    }\n  } else {\n    throw new Error('User Error: Literal not recognized.');\n  }\n};\n\nconst tokenize = (text: string): Token[] => {\n  let tokens: Token[] = [];\n  for (let i=0; i < text.length; i++) {\n    // Char at i is a number or \".\".\n    if (!isNaN(parseInt(text.charAt(i))) || text.charAt(i) === '.') {\n      let j = i;\n      while (j < text.length && (!isNaN(parseInt(text.charAt(j))) || text.charAt(j) === '.')) {\n        j += 1;\n      }\n      const literal = text.slice(i, j);\n      const token = tokenizeLiteral(literal);\n      tokens.push(token);\n      i = j-1;\n    // Char at i is an operator.\n    } else if ('()^*/+-'.includes(text.charAt(i))) {\n      const token: Token = {type: 'operator', value: text.charAt(i)}\n      tokens.push(token);\n    } else if (text.charAt(i) !== ' ') {\n      throw new Error('User Error: \"' + text[i] + '\" is not a valid character.');\n    }\n  }\n  return tokens;\n};\n\n// NOT intended to handle errors.\nconst establishNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i < tokens.length; i++) {\n    // Is a candidate for conversion to \"neg\".\n    if (tokens[i].value === '-') {\n      let isNegative = true;\n      // Minus is at the end.\n      if (i+1 === tokens.length) {\n        isNegative = false;\n      // Minus is followed by an operator other than \"(\".\n      } else if (tokens[i+1].type === 'operator' && tokens[i+1].value !== '(') {\n        isNegative = false;\n      // Minus follows a number.\n      } else if (i > 0 && tokens[i-1].type === 'number') {\n        isNegative = false;\n      // Minus is followed by a number followed by an exponent sign (which operates before negative conversion).\n      } else if (i+2 < tokens.length && tokens[i+2].value === '^') {\n        isNegative = false\n      }\n\n      if (isNegative) {\n        newTokens.push({type: 'operator', value: 'neg'})\n      } else {\n        newTokens.push({type: 'operator', value: '-'})\n      }\n    // Not a candidate for conversion to \"neg\".\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value})\n    }\n  }\n  return newTokens;\n};\n\n// Only handles errors related to bad \"neg\"s.\nconst resolveNegatives = (tokens: Token[]): Token[] => {\n  let newTokens: Token[] = [];\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === 'neg') {\n      // Is at the end of expression (internal because it shouldn't have been converted if at end).\n      if (i+1 >= tokens.length) {\n        throw new Error('Internal Error: Expression cannot end with a \"neg\" operator.');\n      } else {\n        const nextToken = tokens[i+1];\n        // Is followed by \"(\".\n        if (nextToken.value === '(') {\n          newTokens.push({type: 'operator', value: 'neg'});\n        // Is followed by a number.\n        } else if (typeof nextToken.value == 'number') {\n          let newValue = -1 * nextToken.value;\n          // DO NOT resolve \"neg 0\" to \"-0\".\n          if (nextToken.value === 0) {\n            newValue = 0;\n          }\n          newTokens.push({type: 'number', value: newValue});\n          i += 1;\n        // Is followed by something other than \"(\" or a number (internal because shouldn't have been converted if so).\n        } else {\n          throw new Error('Internal Error: \"neg\"s must be followed by \"(\" or a number.');\n        }\n      }\n    } else {\n      newTokens.push({type: tokens[i].type, value: tokens[i].value});\n    }\n  }\n  return newTokens;\n};\n\n// Assumes no \"neg\"s or parentheses; handles most other input logic errors.\nconst performMathOperation = (tokens: Token[]): Token[] => {\n  if (tokens.length === 1) {\n    if (tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist only of an operator.');\n    } else {\n      return [{type: 'number', value: tokens[0].value}]; \n    }\n  }\n\n  const tokenValues: TokenValue[] = tokens.map((token) => token.value);\n  const operators = ['^', '*', '/', '+', '-'];\n  let operatorIndex: number | undefined = -1;\n  for (let i=0; i<operators.length; i++) {\n    if (tokenValues.includes(operators[i])) {\n      operatorIndex = tokenValues.indexOf(operators[i]);\n      break;\n    };\n  };\n\n  if (operatorIndex === undefined) {\n    throw new Error('User Error: Multiple tokens in expression with no operator.');\n  } else if (operatorIndex === 0) {\n    throw new Error('User Error: Expression cannot start with an operator.');\n } else if (operatorIndex === tokens.length-1) {\n   throw new Error('User Error: Expression cannot end with an operator.');\n  }\n\n  let newToken: Token | undefined = undefined;\n\n  const leftOperand: Token = tokens[operatorIndex-1];\n  const rightOperand: Token = tokens[operatorIndex+1];\n  const operator: Token = tokens[operatorIndex];\n  if (typeof leftOperand.value === 'number' && typeof rightOperand.value === 'number') {\n    let newValue: number | undefined = undefined;\n    if (operator.value === '^') {\n      if (leftOperand.value < 0 && rightOperand.value % 1 !== 0) {\n        throw new Error('User Error: ' + leftOperand.value.toString() + '^' + rightOperand.value.toString() + ' results in an imaginary number, which is not supported.')\n      }\n      newValue = Math.pow(leftOperand.value, rightOperand.value);\n    } else if (operator.value === '*') {\n      newValue = leftOperand.value*rightOperand.value;\n    } else if (operator.value === '/') {\n      newValue = leftOperand.value/rightOperand.value;\n    } else if (operator.value === '+') {\n      newValue = leftOperand.value+rightOperand.value;\n    } else if (operator.value === '-') {\n      newValue = leftOperand.value-rightOperand.value;\n    }\n    if (newValue === undefined) {\n      throw new Error('Internal Error: \"' + operator.value + '\" operator not recognized.');\n    } else {\n      newToken = {type: 'number', value: newValue};\n    }\n  } else {\n    throw new Error('User Error: \"' + operator.value + '\" operator requires numeric operands.');\n  }\n  \n  if (newToken === undefined) {\n    throw new Error('Internal error: performSimpleOperation function failed.');\n  } else {\n    const leftTokens = tokens.slice(0, operatorIndex-1).map((token) => ({type: token.type, value: token.value}));\n    const rightTokens = tokens.slice(operatorIndex+2).map((token) => ({type: token.type, value: token.value}));\n    const newTokens = leftTokens.concat([newToken]).concat(rightTokens);      \n    return newTokens;\n  }\n};\n\n// Only handles errors to do with parentheses\n// I'm thinking THIS should return a step...\nconst performOperation = (tokens: Token[]): Token[] => {\n  let parenStart: number | undefined = undefined;\n  let parenEnd: number | undefined = undefined;\n  for (let i=0; i<tokens.length; i++) {\n    if (tokens[i].value === '(') {\n      parenStart = i;\n    } else if (tokens[i].value === ')') {\n      parenEnd = i;\n      break;\n    }\n  }\n\n  if ((parenStart === undefined) !== (parenEnd === undefined)) {\n    throw new Error('User Error: Mismatched parentheses.');\n  }\n\n  let newTokens: Token[] | undefined = undefined;\n\n  // We'll be working within parentheses.\n  if (parenStart !== undefined && parenEnd !== undefined) {\n    const contents: Token[] = tokens.slice(parenStart+1, parenEnd);\n    if (contents.length === 0) {\n      throw new Error('User Error: Parentheses cannot be empty.');\n    }\n    const contentsOperated = performMathOperation(contents);\n    // Contents operated contains single number.\n    if (contentsOperated.length === 1 && contentsOperated[0].type === 'number') {\n      // Remove parentheses when concatenating.\n      const leftTokens = tokens.slice(0, parenStart).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd+1).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    // Contents operated contains multiple numbers (error cases handled within perform math operation).\n    } else {\n      const leftTokens = tokens.slice(0, parenStart+1).map((token) => ({type: token.type, value: token.value}));\n      const rightTokens = tokens.slice(parenEnd).map((token) => ({type: token.type, value: token.value}));\n      newTokens = leftTokens.concat(contentsOperated).concat(rightTokens);\n    }\n  // There are no parentheses remaining.\n  } else {\n    newTokens = performMathOperation(tokens);\n  }\n\n  if (newTokens !== undefined) {\n    newTokens = resolveNegatives(newTokens);\n    return newTokens;\n  } else {\n    throw new Error('Internal Error: \"performOperation\" function failed.');\n  }\n};\n\nconst formatOrdinal = (n: number): string => {\n  const nString = n.toString();\n  if (n % 1 !== 0) {\n    return nString + 'th';\n  }\n  const lastDigit = parseInt(nString.charAt(nString.length-1));\n  const truncated = n % 100;\n  let suffix = 'th';\n  if (lastDigit === 1 && truncated !== 11) {\n    suffix = 'st';\n  } else if (lastDigit === 2 && truncated !== 12) {\n    suffix = 'nd';\n  } else if (lastDigit === 3 && truncated !== 13) {\n    suffix = 'rd';\n  }\n  return nString + suffix;\n}\n\nconst formatFloat = (number: number, digits: number): string => {\n  let formatted: number | string = number;\n  // Using workaround to assess digits after decimal, as  \"3.1 % 1\" yields \"0.1000000000000000001\" (not what we want).\n  if (formatted % 1 !== 0 && formatted.toString().split('.')[1].length > digits) {\n    formatted = parseFloat(number.toFixed(digits)).toString() + '...';\n  } else {\n    formatted = number.toString();\n  }\n  return formatted;\n}\n\n// Awkward, but easier & simpler than tracking and passing changes through all of the index-changing operations (math operations, resolving parentheses, resolving negatives).\n// Assumes both sequences describe valid equations.\nconst describeOperation = (prevTokens: Token[], newTokens: Token[]): { operationInput: Interval, operationOutput: Interval, operationDescription: string } => {\n  let i = prevTokens.length-1;\n  let j = newTokens.length-1;\n  // Move along both sets of tokens, iterating backward to ensure that i hits the first operator in cases like \"1*1*1\" to \"1*1\".\n  while (i >= 0 && j >= 0 && prevTokens[i].value === newTokens[j].value) {\n    i -= 1;\n    j -= 1;\n  }\n\n  // Case where input and output share ending numbers (eg. \"1*1+1\" to \"1+1\"), so i continues on to the operator that was resolved.\n    // I believe all remaining cases leave i and j at the end of the input & output sequences.\n    // Including \"(1)\", where there is no operator; and \"1*1*1\" to \"1*1\", where j hits the end of the array.\n  if (prevTokens[i].type === 'operator' && prevTokens[i].value !== ')') {\n    i += 1;\n    j += 1;\n  }\n  const operationOutput: Interval = {\n    start: j,\n    end: j+1\n  };\n  let k = i;\n  // Cases with inputs like \"(1)\", \"(1+1)\", \"neg(1)\", \"neg(1+1)\".\n  if (prevTokens[i].value === ')') {\n    while (k >= 0 && prevTokens[k].value !== '(') {\n      k -= 1;\n    }\n    if (k > 0 && prevTokens[k-1].value === 'neg') {\n      k -= 1;\n    }\n  // Cases with inputs like \"1+1\".\n  } else {\n    k -= 2;\n  }\n  const operationInput: Interval = {\n    start: k,\n    end: i+1\n  }\n  const inputTokens = prevTokens.slice(k, i+1);\n\n  let operatorIndex = 0;\n  for ( ; operatorIndex < inputTokens.length; operatorIndex++) {\n    const token = inputTokens[operatorIndex];\n    if (token.type === 'operator' && typeof token.value === 'string' && !['neg', '(', ')'].includes(token.value)) {\n      break;\n    }\n  }\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n  }\n\n  let description: string | undefined = undefined;\n  console.log('DESCRIBE OPERATION')\n  console.log('input tokens', formatTokens(inputTokens));\n  console.log('operator index', operatorIndex);\n  if (operatorIndex === 0 || operatorIndex === inputTokens.length-1) {\n    throw new Error('Internal Error: \"describeOperation\" function recieved a misplaced operator.');\n  // No operator in expression (eg. \"(1)\" to \"1\").\n  } else if (operatorIndex === inputTokens.length) {\n    description = 'resolve parentheses';\n  } else if (operatorIndex < inputTokens.length) {\n    const leftOperand = inputTokens[operatorIndex-1].value;\n    const rightOperand = inputTokens[operatorIndex+1].value;\n    if (typeof leftOperand !== 'number' || typeof rightOperand !== 'number') {\n      throw new Error('Internal Error: \"describeOperation\" function received invalid operands.');\n    }\n    if (inputTokens[operatorIndex].value === '^') {\n      description = 'raise ' + formatFloat(leftOperand, 3) + ' to the ' + formatOrdinal(rightOperand) + ' power';\n    } else if (inputTokens[operatorIndex].value === '*') {\n      description = 'multiply ' + formatFloat(leftOperand, 3) + ' by ' + formatFloat(rightOperand, 3);\n    } else if (inputTokens[operatorIndex].value === '/') {\n      description = 'divide ' + formatFloat(leftOperand, 3) + ' by ' + formatFloat(rightOperand, 3);\n    } else if (inputTokens[operatorIndex].value === '+') {\n      description = 'add ' + formatFloat(rightOperand, 3) + ' to ' + formatFloat(leftOperand, 3);\n    } else if (inputTokens[operatorIndex].value === '-') {\n      description = 'subtract ' + formatFloat(rightOperand, 3) + ' from ' + formatFloat(leftOperand, 3);\n    }  \n  } else {\n\n  }\n  if (description === undefined) {\n    throw new Error('Internal Error: function \"describeOperation\" failed.');\n  }\n  return {\n    operationInput: operationInput,\n    operationOutput: operationOutput,\n    operationDescription: description\n  };\n};\n\nconst evaluate = (text: string): Step[] | Error => {\n  try {\n    let tokens = tokenize(text);\n    tokens = establishNegatives(tokens);\n    tokens = resolveNegatives(tokens);\n    if (tokens.length === 0) {\n      return [];\n    } else if (tokens.length === 1 && tokens[0].type === 'operator') {\n      throw new Error('User Error: Expression cannot consist of a single operator.');\n    }\n    let prevStep: Step = {\n      tokens: tokens,\n      description: '[Initial description.]',\n      computeNext: null,\n      computed: null,\n    };\n    const steps: Step[] = [];\n    while (prevStep.tokens.length > 1) {\n      const tokens = performOperation(prevStep.tokens);\n      const { operationInput, operationOutput, operationDescription } = describeOperation(prevStep.tokens, tokens);\n      prevStep.computeNext = operationInput;\n      steps.push(prevStep);\n      prevStep = {\n        computeNext: null,\n        tokens: tokens,\n        description: operationDescription,\n        computed: operationOutput\n      }\n    }\n    steps.push(prevStep);\n    return steps;\n  } catch (error) {\n    return error;\n  }\n};\n\nexport {\n  tokenizeLiteral,\n  tokenize,\n  establishNegatives,\n  resolveNegatives,\n  performMathOperation,\n  performOperation,\n  describeOperation,\n  evaluate,\n  formatTokens,\n  formatFloat\n};\n\n// NOTE\n  // Preference is to trust token.type, with typeof used when necessary for type narrowing.\n\n// TODO\n  // Returns and conditionals and exceptions all over the place are leaving things a mess (especially performMathOperation).\n    // In theory having early returns makes it so there are guarantees down the line, but that gets messy fast.....\n  // Ya, checks and exceptions are all over the place. resolve that.\n  // Consider un-refactoring the '\"number\"' back to '\"float\" | \"integer\"', since apparently JS/TS is terrible at discerning floats/ints from numbers\n  // Consider adding \"patentheses\" type, to simplify checking for \"operation but not parentheses\".","import { format } from 'path';\nimport React from 'react';\nimport { colors } from '../constants';\nimport { formatFloat } from '../solve';\nimport type { Token, Step as StepType } from '../solve';\nimport '../styles/Step.css';\n// import { tokenToString } from 'typescript';\n\ntype StepProps = {\n  initial?: boolean,\n  step: StepType,\n  index: number\n}\n\ntype IndexedToken = {\n  token: Token,\n  index: number\n}\n\nconst Step = ({ initial = false, step, index }: StepProps) => {\n  let computeNextInterval = step.computeNext || { start: 0, end: 0 };\n  const indexedTokens = step.tokens.map((token, i) => ({ token: token, index: i }));\n  const computedColor = step.computed ? colors[(index-1) % colors.length] : 'white';\n  const computeNextColor = step.computeNext ? colors[index % colors.length] : 'white';\n\n  const mapTokens = ({ token, index }: IndexedToken): React.ReactNode => {\n    let adjustedValue = token.value;\n    if (typeof adjustedValue === 'number') {\n      // Display more of decimal portion if it's the final result.\n      if (step.tokens.length === 1) {\n        adjustedValue = formatFloat(adjustedValue, 10);\n      } else {\n        adjustedValue = formatFloat(adjustedValue, 3);\n      }\n    }\n\n    if (index > 0 && step.tokens[index-1].value !== 'neg') {\n      adjustedValue = ' ' + adjustedValue;\n    }\n    if (adjustedValue === ' neg') {\n      adjustedValue = ' -';\n    }\n    if (step.computed !== null && index === step.computed.start) {\n      return (<span key={index} className='computed' style={{color: computedColor, fontWeight: 'bold'}}>{adjustedValue}</span>);\n    } else {\n      return (<span key={index}>{adjustedValue}</span>);\n    }\n  };\n  const preComputeNext = indexedTokens.slice(0, computeNextInterval.start).map(mapTokens);\n  const postComputeNext = indexedTokens.slice(computeNextInterval.end).map(mapTokens);\n  const computeNextInner = indexedTokens.slice(computeNextInterval.start, computeNextInterval.end).map(mapTokens);\n  let computeNext = (<></>)\n  if (computeNextInner.length > 0) {\n    computeNext = (<span className='compute-next' style={{border: '2px solid ' + computeNextColor}}>{computeNextInner}</span>)\n  }\n  return (\n    <div className={initial ? 'step step-initial' : 'step step-next'}>\n    <span className='expression'>\n      {preComputeNext}\n      {computeNext}\n      {postComputeNext}\n    </span>\n    </div>\n  );\n};\n\nexport default Step;\n","import React from 'react';\nimport { colors } from '../constants';\nimport '../styles/Description.css';\n\ntype DescriptionProps = {\n  description: string,\n  index: number\n}\n\nconst Description = ({ description, index }: DescriptionProps) => {\n  const descriptionColor = colors[(index) % colors.length];\n  return (\n    <div className='description' style={{color: descriptionColor}}>\n      {description}\n    </div>\n  );\n};\n\nexport default Description;\n","import React from 'react';\nimport '../styles/ErrorMessage.css';\n\ntype ErrorMessageProps = {\n  error: Error | null,\n}\n\nconst ErrorMessage = ({ error }: ErrorMessageProps) => {\n  const softenMessage = (message: string) => {\n    let newMessage = message;\n    if (newMessage.split('Internal Error').length > 1) {\n      return newMessage;\n    } else {\n      newMessage = newMessage.split('User Error: ').join('');\n      newMessage = newMessage.toLowerCase();\n      if (newMessage.charAt(newMessage.length-1) === '.') {\n        newMessage = newMessage.slice(0, newMessage.length-1);\n      }\n      return newMessage;\n    }\n  }\n  if (error === null) {\n    return null;\n  } else {\n    return (\n      <div className='error'>\n        {softenMessage(error.message)}\n      </div>\n    );\n  }\n};\n\nexport default ErrorMessage;\n","import React from 'react';\nimport Input from './Input';\nimport Step from './Step';\nimport Description from './Description';\nimport ErrorMessage from './ErrorMessage';\nimport {\n  evaluate,\n  formatTokens\n} from '../solve';\nimport type {\n  // Token,\n  Step as StepType\n} from '../solve';\nimport '../styles/Solver.css';\n\nconst Solver = () => {\n  const [expression, setExpression] = React.useState('');\n  const [steps, setSteps] = React.useState<StepType[] | null>(null)\n  const [error, setError] = React.useState<Error | null>(null);\n\n  const updateState = (text: string) => {\n    setExpression(text);\n    const evaluateResult = evaluate(text);\n    if (evaluateResult instanceof Error) {\n      console.log(evaluateResult.message);\n      setSteps(null);\n      setError(evaluateResult);\n    } else {\n      evaluateResult.forEach((step) => {\n        console.log(formatTokens(step.tokens));\n      });\n      setSteps(evaluateResult);\n      setError(null);\n    };\n  }\n\n  // Call once at start to sync expression, steps, error.\n  React.useEffect(() => {\n    updateState('1-2+-(4/2-1)^3*2');\n  }, [])\n\n  const onInputChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n    const text = event.target.value;\n    updateState(text);\n  };\n\n  const getDescriptions = () => {\n    if (steps !== null && steps.length > 1) {\n      return steps.slice(1).map((step, i) => (\n        <Description\n          key={i}\n          description={step.description}\n          index={i}\n        />\n      ));\n    } else {\n      return null;\n    }\n  }\n\n  const getSteps = () => {\n    if (steps !== null && steps.length === 0) {\n      return null;\n    } else if (steps !== null && steps.length > 0) {\n      return (\n        <>\n          <Step\n            key={0}\n            initial={true}\n            step={steps[0]}\n            index={0}\n            />\n          {steps.slice(1).map((step, i) => (\n            <Step\n              key={i+1}\n              step={step}\n              index={i+1}\n            />\n          ))}\n       </>\n      );\n    } else {\n      return null;\n      // if (error !== null) {\n      //   return (\n      //     <ErrorItem\n      //       error={error}\n      //     />\n      //   );  \n      // } else {\n      //   return (\n      //     <ErrorItem\n      //       error={new Error('Internal Error: Evaluation not available.')}\n      //     />\n      //   );\n      // }\n    }\n  }\n  return (\n    <div className='solver'>\n      <div className = 'solver-left'>\n        <Input\n          value={expression}\n          onChange={onInputChange}\n        />\n        {getDescriptions()}\n      </div>\n      {/* <div className='solver-middle' /> */}\n      <div className = 'solver-right'>\n        {getSteps()}\n      </div>\n      <ErrorMessage error={error} />\n    </div>\n  );\n};\n\nexport default Solver;\n","import React from 'react';\nimport Solver from './Solver';\nimport '../styles/App.css';\n\nconst App = () => {\n  return (\n    <div className='app'>\n      <Solver />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.css';\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}